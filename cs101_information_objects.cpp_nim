##
##   Copyright 2016 MZ Automation GmbH
##
##   This file is part of lib60870-C
##
##   lib60870-C is free software: you can redistribute it and/or modify
##   it under the terms of the GNU General Public License as published by
##   the Free Software Foundation, either version 3 of the License, or
##   (at your option) any later version.
##
##   lib60870-C is distributed in the hope that it will be useful,
##   but WITHOUT ANY WARRANTY; without even the implied warranty of
##   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##   GNU General Public License for more details.
##
##   You should have received a copy of the GNU General Public License
##   along with lib60870-C.  If not, see <http://www.gnu.org/licenses/>.
##
##   See COPYING file for the complete license text.
##

import
  iec60870_common, apl_types_internal, cs101_information_objects,
  information_objects_internal, lib_memory, frame, platform_endian

type
  EncodeFunction* = proc (self: InformationObject; frame: Frame;
                       parameters: CS101_AppLayerParameters; isSequence: bool): bool
  DestroyFunction* = proc (self: InformationObject)
  sInformationObjectVFT* {.bycopy.} = object
    encode*: EncodeFunction
    destroy*: DestroyFunction  ## const char* (*toString)(InformationObject self);


## ****************************************
##  Basic data types
## **************************************

proc SingleEvent_setEventState*(self: SingleEvent; eventState: EventState) =
  var value: uint8_t = self[]
  value = value and 0x00000000
  inc(value, eventState)
  self[] = value

proc SingleEvent_getEventState*(self: SingleEvent): EventState =
  return (EventState)(self[] and 0x00000000)

proc SingleEvent_setQDP*(self: SingleEvent; qdp: QualityDescriptorP) =
  var value: uint8_t = self[]
  value = value and 0x00000000
  inc(value, qdp)
  self[] = value

proc SingleEvent_getQDP*(self: SingleEvent): QualityDescriptorP =
  return (QualityDescriptor)(self[] and 0x00000000)

proc StatusAndStatusChangeDetection_getSTn*(self: StatusAndStatusChangeDetection): uint16_t =
  return (uint16_t)(self.encodedValue[0] + 256 * self.encodedValue[1])

proc StatusAndStatusChangeDetection_getCDn*(self: StatusAndStatusChangeDetection): uint16_t =
  return (uint16_t)(self.encodedValue[2] + 256 * self.encodedValue[3])

proc StatusAndStatusChangeDetection_setSTn*(self: StatusAndStatusChangeDetection;
    value: uint16_t) =
  self.encodedValue[0] = (uint8_t)(value mod 256)
  self.encodedValue[1] = (uint8_t)(value div 256)

proc StatusAndStatusChangeDetection_getST*(self: StatusAndStatusChangeDetection;
    index: cint): bool =
  if (index >= 0) and (index < 16):
    return (int)(StatusAndStatusChangeDetection_getSTn(self) and (2 xor index)) != 0
  else:
    return false

proc StatusAndStatusChangeDetection_getCD*(self: StatusAndStatusChangeDetection;
    index: cint): bool =
  if (index >= 0) and (index < 16):
    return (int)(StatusAndStatusChangeDetection_getCDn(self) and (2 xor index)) != 0
  else:
    return false

## ****************************************
##  Information object hierarchy
## ***************************************
## ****************************************
##  InformationObject (base class)
## ***************************************

type
  sInformationObject* {.bycopy.} = object
    objectAddress*: cint
    `type`*: TypeID
    virtualFunctionTable*: InformationObjectVFT


proc InformationObject_encode*(self: InformationObject; frame: Frame;
                              parameters: CS101_AppLayerParameters;
                              isSequence: bool): bool =
  return self.virtualFunctionTable.encode(self, frame, parameters, isSequence)

proc InformationObject_destroy*(self: InformationObject) =
  self.virtualFunctionTable.destroy(self)

proc InformationObject_getObjectAddress*(self: InformationObject): cint =
  return self.objectAddress

proc InformationObject_setObjectAddress*(self: InformationObject; ioa: cint) =
  self.objectAddress = ioa

proc InformationObject_getType*(self: InformationObject): TypeID =
  return self.`type`

proc InformationObject_encodeBase*(self: InformationObject; frame: Frame;
                                  parameters: CS101_AppLayerParameters;
                                  isSequence: bool) =
  if not isSequence:
    Frame_setNextByte(frame, (uint8_t)(self.objectAddress and 0x00000000))
    if parameters.sizeOfIOA > 1:
      Frame_setNextByte(frame, (uint8_t)((self.objectAddress div 0x00000000) and
          0x00000000))
    if parameters.sizeOfIOA > 2:
      Frame_setNextByte(frame, (uint8_t)((self.objectAddress div 0x00000000) and
          0x00000000))

proc InformationObject_ParseObjectAddress*(parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; startIndex: cint): cint =
  ##  parse information object address
  var ioa: cint = msg[startIndex]
  if parameters.sizeOfIOA > 1:
    inc(ioa, (msg[startIndex + 1] * 0x00000000))
  if parameters.sizeOfIOA > 2:
    inc(ioa, (msg[startIndex + 2] * 0x00000000))
  return ioa

proc InformationObject_getFromBuffer*(self: InformationObject;
                                     parameters: CS101_AppLayerParameters;
                                     msg: ptr uint8_t; startIndex: cint) =
  ##  parse information object address
  self.objectAddress = InformationObject_ParseObjectAddress(parameters, msg,
      startIndex)

proc InformationObject_getMaxSizeInMemory*(): cint =
  return sizeof(uInformationObject)

## *********************************************
##  SinglePointInformation
## ********************************************

proc SinglePointInformation_encode*(self: SinglePointInformation; frame: Frame;
                                   parameters: CS101_AppLayerParameters;
                                   isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var val: uint8_t = cast[uint8_t](self.quality)
  if self.value:
    inc(val)
  Frame_setNextByte(frame, val)
  return true

var singlePointInformationVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SinglePointInformation_encode),
    cast[DestroyFunction](SinglePointInformation_destroy)]

proc SinglePointInformation_initialize*(self: SinglePointInformation) =
  self.virtualFunctionTable = addr((singlePointInformationVFT))
  self.`type` = M_SP_NA_1

proc SinglePointInformation_create*(self: SinglePointInformation; ioa: cint;
                                   value: bool; quality: QualityDescriptor): SinglePointInformation =
  if self == nil:
    self = cast[SinglePointInformation](GLOBAL_CALLOC(1,
        sizeof(sSinglePointInformation)))
  if self != nil:
    SinglePointInformation_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.quality = quality
  return self

proc SinglePointInformation_destroy*(self: SinglePointInformation) =
  GLOBAL_FREEMEM(self)

proc SinglePointInformation_getFromBuffer*(self: SinglePointInformation;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): SinglePointInformation =
  ##  TODO check message size
  if self == nil:
    self = cast[SinglePointInformation](GLOBAL_MALLOC(
        sizeof(sSinglePointInformation)))
  if self != nil:
    SinglePointInformation_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var siq: uint8_t = msg[startIndex]
    self.value = ((siq and 0x00000000) == 0x00000000)
    self.quality = (QualityDescriptor)(siq and 0x00000000)
  return self

proc SinglePointInformation_getValue*(self: SinglePointInformation): bool =
  return self.value

proc SinglePointInformation_getQuality*(self: SinglePointInformation): QualityDescriptor =
  return self.quality

## *********************************************
##  StepPositionInformation
## ********************************************

proc StepPositionInformation_encode*(self: StepPositionInformation; frame: Frame;
                                    parameters: CS101_AppLayerParameters;
                                    isSequence: bool): bool =
  var size: cint = if isSequence: 2 else: (parameters.sizeOfIOA + 2)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.vti)
  Frame_setNextByte(frame, cast[uint8_t](self.quality))
  return true

var stepPositionInformationVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](StepPositionInformation_encode),
    cast[DestroyFunction](StepPositionInformation_destroy)]

proc StepPositionInformation_initialize*(self: StepPositionInformation) =
  self.virtualFunctionTable = addr((stepPositionInformationVFT))
  self.`type` = M_ST_NA_1

proc StepPositionInformation_create*(self: StepPositionInformation; ioa: cint;
                                    value: cint; isTransient: bool;
                                    quality: QualityDescriptor): StepPositionInformation =
  if self == nil:
    self = cast[StepPositionInformation](GLOBAL_CALLOC(1,
        sizeof(sStepPositionInformation)))
  if self != nil:
    StepPositionInformation_initialize(self)
    self.objectAddress = ioa
    if value > 63:
      value = 63
    elif value < -64:
      value = -64
    if value < 0:
      value = value + 128
    self.vti = value
    if isTransient:
      self.vti = self.vti or 0x00000000
    self.quality = quality
  return self

proc StepPositionInformation_destroy*(self: StepPositionInformation) =
  GLOBAL_FREEMEM(self)

proc StepPositionInformation_getObjectAddress*(self: StepPositionInformation): cint =
  return self.objectAddress

proc StepPositionInformation_getValue*(self: StepPositionInformation): cint =
  var value: cint = (self.vti and 0x00000000)
  if value > 63:
    value = value - 128
  return value

proc StepPositionInformation_isTransient*(self: StepPositionInformation): bool =
  return (self.vti and 0x00000000) == 0x00000000

proc StepPositionInformation_getQuality*(self: StepPositionInformation): QualityDescriptor =
  return self.quality

proc StepPositionInformation_getFromBuffer*(self: StepPositionInformation;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): StepPositionInformation =
  if self == nil:
    self = cast[StepPositionInformation](GLOBAL_MALLOC(
        sizeof(sStepPositionInformation)))
  if self != nil:
    StepPositionInformation_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.vti = msg[inc(startIndex)]
    self.quality = cast[QualityDescriptor](msg[startIndex])
  return self

## *********************************************
##  StepPositionWithCP56Time2a
## ********************************************

proc StepPositionWithCP56Time2a_encode*(self: StepPositionWithCP56Time2a;
                                       frame: Frame;
                                       parameters: CS101_AppLayerParameters;
                                       isSequence: bool): bool =
  var size: cint = if isSequence: 9 else: (parameters.sizeOfIOA + 9)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.vti)
  Frame_setNextByte(frame, cast[uint8_t](self.quality))
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return false

var stepPositionWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](StepPositionWithCP56Time2a_encode),
    cast[DestroyFunction](StepPositionWithCP56Time2a_destroy)]

proc StepPositionWithCP56Time2a_initialize*(self: StepPositionWithCP56Time2a) =
  self.virtualFunctionTable = addr((stepPositionWithCP56Time2aVFT))
  self.`type` = M_ST_TB_1

proc StepPositionWithCP56Time2a_destroy*(self: StepPositionWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc StepPositionWithCP56Time2a_create*(self: StepPositionWithCP56Time2a;
                                       ioa: cint; value: cint; isTransient: bool;
                                       quality: QualityDescriptor;
                                       timestamp: CP56Time2a): StepPositionWithCP56Time2a =
  if self == nil:
    self = cast[StepPositionWithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sStepPositionWithCP56Time2a)))
  if self != nil:
    StepPositionWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    if value > 63:
      value = 63
    elif value < -64:
      value = -64
    if value < 0:
      value = value + 128
    self.vti = value
    if isTransient:
      self.vti = self.vti or 0x00000000
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc StepPositionWithCP56Time2a_getTimestamp*(self: StepPositionWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc StepPositionWithCP56Time2a_getFromBuffer*(self: StepPositionWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): StepPositionWithCP56Time2a =
  if self == nil:
    self = cast[StepPositionWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sStepPositionWithCP56Time2a)))
  if self != nil:
    StepPositionWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.vti = msg[inc(startIndex)]
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## *********************************************
##  StepPositionWithCP24Time2a
## ********************************************

proc StepPositionWithCP24Time2a_encode*(self: StepPositionWithCP56Time2a;
                                       frame: Frame;
                                       parameters: CS101_AppLayerParameters;
                                       isSequence: bool): bool =
  var size: cint = if isSequence: 5 else: (parameters.sizeOfIOA + 5)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.vti)
  Frame_setNextByte(frame, cast[uint8_t](self.quality))
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var stepPositionWithCP24Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](StepPositionWithCP24Time2a_encode),
    cast[DestroyFunction](StepPositionWithCP24Time2a_destroy)]

proc StepPositionWithCP24Time2a_initialize*(self: StepPositionWithCP24Time2a) =
  self.virtualFunctionTable = addr((stepPositionWithCP24Time2aVFT))
  self.`type` = M_ST_TA_1

proc StepPositionWithCP24Time2a_destroy*(self: StepPositionWithCP24Time2a) =
  GLOBAL_FREEMEM(self)

proc StepPositionWithCP24Time2a_create*(self: StepPositionWithCP24Time2a;
                                       ioa: cint; value: cint; isTransient: bool;
                                       quality: QualityDescriptor;
                                       timestamp: CP24Time2a): StepPositionWithCP24Time2a =
  if self == nil:
    self = cast[StepPositionWithCP24Time2a](GLOBAL_CALLOC(1,
        sizeof(sStepPositionWithCP24Time2a)))
  if self != nil:
    StepPositionWithCP24Time2a_initialize(self)
    self.objectAddress = ioa
    if value > 63:
      value = 63
    elif value < -64:
      value = -64
    if value < 0:
      value = value + 128
    self.vti = value
    if isTransient:
      self.vti = self.vti or 0x00000000
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc StepPositionWithCP24Time2a_getTimestamp*(self: StepPositionWithCP24Time2a): CP24Time2a =
  return addr((self.timestamp))

proc StepPositionWithCP24Time2a_getFromBuffer*(self: StepPositionWithCP24Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): StepPositionWithCP24Time2a =
  if self == nil:
    self = cast[StepPositionWithCP24Time2a](GLOBAL_MALLOC(
        sizeof(sStepPositionWithCP24Time2a)))
  if self != nil:
    StepPositionWithCP24Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.vti = msg[inc(startIndex)]
    self.quality = cast[QualityDescriptor](msg[startIndex])
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## *********************************************
##  DoublePointInformation
## ********************************************

proc DoublePointInformation_encode*(self: DoublePointInformation; frame: Frame;
                                   parameters: CS101_AppLayerParameters;
                                   isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var val: uint8_t = cast[uint8_t](self.quality)
  inc(val, cast[cint](self.value))
  Frame_setNextByte(frame, val)
  return true

var doublePointInformationVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](DoublePointInformation_encode),
    cast[DestroyFunction](DoublePointInformation_destroy)]

proc DoublePointInformation_destroy*(self: DoublePointInformation) =
  GLOBAL_FREEMEM(self)

proc DoublePointInformation_initialize*(self: DoublePointInformation) =
  self.virtualFunctionTable = addr((doublePointInformationVFT))
  self.`type` = M_DP_NA_1

proc DoublePointInformation_create*(self: DoublePointInformation; ioa: cint;
                                   value: DoublePointValue;
                                   quality: QualityDescriptor): DoublePointInformation =
  if self == nil:
    self = cast[DoublePointInformation](GLOBAL_CALLOC(1,
        sizeof(sDoublePointInformation)))
  if self != nil:
    DoublePointInformation_initialize(self)
  self.objectAddress = ioa
  self.value = value
  self.quality = quality
  return self

proc DoublePointInformation_getValue*(self: DoublePointInformation): DoublePointValue =
  return self.value

proc DoublePointInformation_getQuality*(self: DoublePointInformation): QualityDescriptor =
  return self.quality

proc DoublePointInformation_getFromBuffer*(self: DoublePointInformation;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): DoublePointInformation =
  if self == nil:
    self = cast[DoublePointInformation](GLOBAL_MALLOC(
        sizeof(sDoublePointInformation)))
  if self != nil:
    DoublePointInformation_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var diq: uint8_t = msg[inc(startIndex)]
    self.value = (DoublePointValue)(diq and 0x00000000)
    self.quality = (QualityDescriptor)(diq and 0x00000000)
  return self

## ******************************************
##  DoublePointWithCP24Time2a
## *****************************************

proc DoublePointWithCP24Time2a_encode*(self: DoublePointWithCP24Time2a;
                                      frame: Frame;
                                      parameters: CS101_AppLayerParameters;
                                      isSequence: bool): bool =
  var size: cint = if isSequence: 4 else: (parameters.sizeOfIOA + 4)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var val: uint8_t = cast[uint8_t](self.quality)
  inc(val, cast[cint](self.value))
  Frame_setNextByte(frame, val)
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var doublePointWithCP24Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](DoublePointWithCP24Time2a_encode),
    cast[DestroyFunction](DoublePointWithCP24Time2a_destroy)]

proc DoublePointWithCP24Time2a_destroy*(self: DoublePointWithCP24Time2a) =
  GLOBAL_FREEMEM(self)

proc DoublePointWithCP24Time2a_initialize*(self: DoublePointWithCP24Time2a) =
  self.virtualFunctionTable = addr((doublePointWithCP24Time2aVFT))
  self.`type` = M_DP_TA_1

proc DoublePointWithCP24Time2a_create*(self: DoublePointWithCP24Time2a; ioa: cint;
                                      value: DoublePointValue;
                                      quality: QualityDescriptor;
                                      timestamp: CP24Time2a): DoublePointWithCP24Time2a =
  if self == nil:
    self = cast[DoublePointWithCP24Time2a](GLOBAL_CALLOC(1,
        sizeof(sDoublePointWithCP24Time2a)))
  if self != nil:
    DoublePointWithCP24Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc DoublePointWithCP24Time2a_getTimestamp*(self: DoublePointWithCP24Time2a): CP24Time2a =
  return addr((self.timestamp))

proc DoublePointWithCP24Time2a_getFromBuffer*(self: DoublePointWithCP24Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): DoublePointWithCP24Time2a =
  if self == nil:
    self = cast[DoublePointWithCP24Time2a](GLOBAL_MALLOC(
        sizeof(sDoublePointWithCP24Time2a)))
  if self != nil:
    DoublePointWithCP24Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var diq: uint8_t = msg[inc(startIndex)]
    self.value = (DoublePointValue)(diq and 0x00000000)
    self.quality = (QualityDescriptor)(diq and 0x00000000)
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ******************************************
##  DoublePointWithCP56Time2a
## *****************************************

proc DoublePointWithCP56Time2a_encode*(self: DoublePointWithCP56Time2a;
                                      frame: Frame;
                                      parameters: CS101_AppLayerParameters;
                                      isSequence: bool): bool =
  var size: cint = if isSequence: 8 else: (parameters.sizeOfIOA + 8)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var val: uint8_t = cast[uint8_t](self.quality)
  inc(val, cast[cint](self.value))
  Frame_setNextByte(frame, val)
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var doublePointWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](DoublePointWithCP56Time2a_encode),
    cast[DestroyFunction](DoublePointWithCP56Time2a_destroy)]

proc DoublePointWithCP56Time2a_destroy*(self: DoublePointWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc DoublePointWithCP56Time2a_initialize*(self: DoublePointWithCP56Time2a) =
  self.virtualFunctionTable = addr((doublePointWithCP56Time2aVFT))
  self.`type` = M_DP_TB_1

proc DoublePointWithCP56Time2a_create*(self: DoublePointWithCP56Time2a; ioa: cint;
                                      value: DoublePointValue;
                                      quality: QualityDescriptor;
                                      timestamp: CP56Time2a): DoublePointWithCP56Time2a =
  if self == nil:
    self = cast[DoublePointWithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sDoublePointWithCP56Time2a)))
  if self != nil:
    DoublePointWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc DoublePointWithCP56Time2a_getTimestamp*(self: DoublePointWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc DoublePointWithCP56Time2a_getFromBuffer*(self: DoublePointWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): DoublePointWithCP56Time2a =
  if self == nil:
    self = cast[DoublePointWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sDoublePointWithCP56Time2a)))
  if self != nil:
    DoublePointWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var diq: uint8_t = msg[inc(startIndex)]
    self.value = (DoublePointValue)(diq and 0x00000000)
    self.quality = (QualityDescriptor)(diq and 0x00000000)
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ******************************************
##  SinglePointWithCP24Time2a
## *****************************************

proc SinglePointWithCP24Time2a_encode*(self: SinglePointWithCP24Time2a;
                                      frame: Frame;
                                      parameters: CS101_AppLayerParameters;
                                      isSequence: bool): bool =
  var size: cint = if isSequence: 4 else: (parameters.sizeOfIOA + 4)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var val: uint8_t = cast[uint8_t](self.quality)
  if self.value:
    inc(val)
  Frame_setNextByte(frame, val)
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var singlePointWithCP24Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SinglePointWithCP24Time2a_encode),
    cast[DestroyFunction](SinglePointWithCP24Time2a_destroy)]

proc SinglePointWithCP24Time2a_destroy*(self: SinglePointWithCP24Time2a) =
  GLOBAL_FREEMEM(self)

proc SinglePointWithCP24Time2a_initialize*(self: SinglePointWithCP24Time2a) =
  self.virtualFunctionTable = addr((singlePointWithCP24Time2aVFT))
  self.`type` = M_SP_TA_1

proc SinglePointWithCP24Time2a_create*(self: SinglePointWithCP24Time2a; ioa: cint;
                                      value: bool; quality: QualityDescriptor;
                                      timestamp: CP24Time2a): SinglePointWithCP24Time2a =
  if self == nil:
    self = cast[SinglePointWithCP24Time2a](GLOBAL_CALLOC(1,
        sizeof(sSinglePointWithCP24Time2a)))
  if self != nil:
    SinglePointWithCP24Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc SinglePointWithCP24Time2a_getTimestamp*(self: SinglePointWithCP24Time2a): CP24Time2a =
  return addr((self.timestamp))

proc SinglePointWithCP24Time2a_getFromBuffer*(self: SinglePointWithCP24Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): SinglePointWithCP24Time2a =
  if self == nil:
    self = cast[SinglePointWithCP24Time2a](GLOBAL_MALLOC(
        sizeof(sSinglePointWithCP24Time2a)))
  if self != nil:
    SinglePointWithCP24Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var siq: uint8_t = msg[inc(startIndex)]
    self.value = ((siq and 0x00000000) == 0x00000000)
    self.quality = (QualityDescriptor)(siq and 0x00000000)
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ******************************************
##  SinglePointWithCP56Time2a
## *****************************************

proc SinglePointWithCP56Time2a_encode*(self: SinglePointWithCP56Time2a;
                                      frame: Frame;
                                      parameters: CS101_AppLayerParameters;
                                      isSequence: bool): bool =
  var size: cint = if isSequence: 8 else: (parameters.sizeOfIOA + 8)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var val: uint8_t = cast[uint8_t](self.quality)
  if self.value:
    inc(val)
  Frame_setNextByte(frame, val)
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var singlePointWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SinglePointWithCP56Time2a_encode),
    cast[DestroyFunction](SinglePointWithCP56Time2a_destroy)]

proc SinglePointWithCP56Time2a_initialize*(self: SinglePointWithCP56Time2a) =
  self.virtualFunctionTable = addr((singlePointWithCP56Time2aVFT))
  self.`type` = M_SP_TB_1

proc SinglePointWithCP56Time2a_create*(self: SinglePointWithCP56Time2a; ioa: cint;
                                      value: bool; quality: QualityDescriptor;
                                      timestamp: CP56Time2a): SinglePointWithCP56Time2a =
  if self == nil:
    self = cast[SinglePointWithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sSinglePointWithCP56Time2a)))
  if self != nil:
    SinglePointWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc SinglePointWithCP56Time2a_destroy*(self: SinglePointWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc SinglePointWithCP56Time2a_getTimestamp*(self: SinglePointWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc SinglePointWithCP56Time2a_getFromBuffer*(self: SinglePointWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): SinglePointWithCP56Time2a =
  if self == nil:
    self = cast[SinglePointWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sSinglePointWithCP56Time2a)))
  if self != nil:
    SinglePointWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var siq: uint8_t = msg[inc(startIndex)]
    self.value = ((siq and 0x00000000) == 0x00000000)
    self.quality = (QualityDescriptor)(siq and 0x00000000)
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## *********************************************
##  BitString32
## ********************************************

proc BitString32_encode*(self: BitString32; frame: Frame;
                        parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 5 else: (parameters.sizeOfIOA + 5)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var value: cint = self.value
  Frame_setNextByte(frame, (uint8_t)(value mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)((value div 0x00000000) mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)((value div 0x00000000) mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)(value div 0x00000000))
  Frame_setNextByte(frame, cast[uint8_t](self.quality))
  return true

var bitString32VFT*: sInformationObjectVFT = [
    cast[EncodeFunction](BitString32_encode),
    cast[DestroyFunction](BitString32_destroy)]

proc BitString32_initialize*(self: BitString32) =
  self.virtualFunctionTable = addr((bitString32VFT))
  self.`type` = M_BO_NA_1

proc BitString32_destroy*(self: BitString32) =
  GLOBAL_FREEMEM(self)

proc BitString32_create*(self: BitString32; ioa: cint; value: uint32_t): BitString32 =
  if self == nil:
    self = cast[BitString32](GLOBAL_CALLOC(1, sizeof(sBitString32)))
  if self != nil:
    BitString32_initialize(self)
    self.objectAddress = ioa
    self.value = value
  return self

proc BitString32_getValue*(self: BitString32): uint32_t =
  return self.value

proc BitString32_getQuality*(self: BitString32): QualityDescriptor =
  return self.quality

proc BitString32_getFromBuffer*(self: BitString32;
                               parameters: CS101_AppLayerParameters;
                               msg: ptr uint8_t; msgSize: cint; startIndex: cint;
                               isSequence: bool): BitString32 =
  if self == nil:
    self = cast[BitString32](GLOBAL_MALLOC(sizeof(sBitString32)))
  if self != nil:
    BitString32_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var value: uint32_t
    value = msg[inc(startIndex)]
    inc(value, (cast[uint32_t](msg[inc(startIndex)] * 0x00000000)))
    inc(value, (cast[uint32_t](msg[inc(startIndex)] * 0x00000000)))
    inc(value, (cast[uint32_t](msg[inc(startIndex)] * 0x00000000)))
    self.value = value
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
  return self

## *********************************************
##  Bitstring32WithCP24Time2a
## ********************************************

proc Bitstring32WithCP24Time2a_encode*(self: Bitstring32WithCP24Time2a;
                                      frame: Frame;
                                      parameters: CS101_AppLayerParameters;
                                      isSequence: bool): bool =
  var size: cint = if isSequence: 8 else: (parameters.sizeOfIOA + 8)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var value: cint = self.value
  Frame_setNextByte(frame, (uint8_t)(value mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)((value div 0x00000000) mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)((value div 0x00000000) mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)(value div 0x00000000))
  Frame_setNextByte(frame, cast[uint8_t](self.quality))
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var bitstring32WithCP24Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](Bitstring32WithCP24Time2a_encode),
    cast[DestroyFunction](Bitstring32WithCP24Time2a_destroy)]

proc Bitstring32WithCP24Time2a_initialize*(self: Bitstring32WithCP24Time2a) =
  self.virtualFunctionTable = addr((bitstring32WithCP24Time2aVFT))
  self.`type` = M_BO_TA_1

proc Bitstring32WithCP24Time2a_destroy*(self: Bitstring32WithCP24Time2a) =
  GLOBAL_FREEMEM(self)

proc Bitstring32WithCP24Time2a_create*(self: Bitstring32WithCP24Time2a; ioa: cint;
                                      value: uint32_t; timestamp: CP24Time2a): Bitstring32WithCP24Time2a =
  if self == nil:
    self = cast[Bitstring32WithCP24Time2a](GLOBAL_CALLOC(1,
        sizeof(sBitstring32WithCP24Time2a)))
  if self != nil:
    Bitstring32WithCP24Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.timestamp = timestamp[]
  return self

proc Bitstring32WithCP24Time2a_getTimestamp*(self: Bitstring32WithCP24Time2a): CP24Time2a =
  return addr((self.timestamp))

proc Bitstring32WithCP24Time2a_getFromBuffer*(self: Bitstring32WithCP24Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): Bitstring32WithCP24Time2a =
  if self == nil:
    self = cast[Bitstring32WithCP24Time2a](GLOBAL_MALLOC(
        sizeof(sBitstring32WithCP24Time2a)))
  if self != nil:
    Bitstring32WithCP24Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var value: uint32_t
    value = msg[inc(startIndex)]
    inc(value, (cast[uint32_t](msg[inc(startIndex)] * 0x00000000)))
    inc(value, (cast[uint32_t](msg[inc(startIndex)] * 0x00000000)))
    inc(value, (cast[uint32_t](msg[inc(startIndex)] * 0x00000000)))
    self.value = value
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## *********************************************
##  Bitstring32WithCP56Time2a
## ********************************************

proc Bitstring32WithCP56Time2a_encode*(self: Bitstring32WithCP56Time2a;
                                      frame: Frame;
                                      parameters: CS101_AppLayerParameters;
                                      isSequence: bool): bool =
  var size: cint = if isSequence: 12 else: (parameters.sizeOfIOA + 12)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var value: cint = self.value
  Frame_setNextByte(frame, (uint8_t)(value mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)((value div 0x00000000) mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)((value div 0x00000000) mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)(value div 0x00000000))
  Frame_setNextByte(frame, cast[uint8_t](self.quality))
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var bitstring32WithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](Bitstring32WithCP56Time2a_encode),
    cast[DestroyFunction](Bitstring32WithCP56Time2a_destroy)]

proc Bitstring32WithCP56Time2a_initialize*(self: Bitstring32WithCP56Time2a) =
  self.virtualFunctionTable = addr((bitstring32WithCP56Time2aVFT))
  self.`type` = M_BO_TB_1

proc Bitstring32WithCP56Time2a_destroy*(self: Bitstring32WithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc Bitstring32WithCP56Time2a_create*(self: Bitstring32WithCP56Time2a; ioa: cint;
                                      value: uint32_t; timestamp: CP56Time2a): Bitstring32WithCP56Time2a =
  if self == nil:
    self = cast[Bitstring32WithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sBitstring32WithCP56Time2a)))
  if self != nil:
    Bitstring32WithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.timestamp = timestamp[]
  return self

proc Bitstring32WithCP56Time2a_getTimestamp*(self: Bitstring32WithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc Bitstring32WithCP56Time2a_getFromBuffer*(self: Bitstring32WithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): Bitstring32WithCP56Time2a =
  if self == nil:
    self = cast[Bitstring32WithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sBitstring32WithCP56Time2a)))
  if self != nil:
    Bitstring32WithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var value: uint32_t
    value = msg[inc(startIndex)]
    inc(value, (cast[uint32_t](msg[inc(startIndex)] * 0x00000000)))
    inc(value, (cast[uint32_t](msg[inc(startIndex)] * 0x00000000)))
    inc(value, (cast[uint32_t](msg[inc(startIndex)] * 0x00000000)))
    self.value = value
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## *********************************************
##  MeasuredValueNormalized
## ********************************************

proc getScaledValue*(encodedValue: ptr uint8_t): cint =
  var value: cint
  value = encodedValue[0]
  inc(value, (encodedValue[1] * 0x00000000))
  if value > 32767:
    value = value - 65536
  return value

proc setScaledValue*(encodedValue: ptr uint8_t; value: cint) =
  var valueToEncode: cint
  if value < 0:
    valueToEncode = value + 65536
  else:
    valueToEncode = value
  encodedValue[0] = (uint8_t)(valueToEncode mod 256)
  encodedValue[1] = (uint8_t)(valueToEncode div 256)

proc MeasuredValueNormalized_encode*(self: MeasuredValueNormalized; frame: Frame;
                                    parameters: CS101_AppLayerParameters;
                                    isSequence: bool): bool =
  var size: cint = if isSequence: 3 else: (parameters.sizeOfIOA + 3)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.encodedValue[0])
  Frame_setNextByte(frame, self.encodedValue[1])
  Frame_setNextByte(frame, cast[uint8_t](self.quality))
  return true

var measuredValueNormalizedVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueNormalized_encode),
    cast[DestroyFunction](MeasuredValueNormalized_destroy)]

proc MeasuredValueNormalized_initialize*(self: MeasuredValueNormalized) =
  self.virtualFunctionTable = addr((measuredValueNormalizedVFT))
  self.`type` = M_ME_NA_1

proc MeasuredValueNormalized_destroy*(self: MeasuredValueNormalized) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueNormalized_create*(self: MeasuredValueNormalized; ioa: cint;
                                    value: cfloat; quality: QualityDescriptor): MeasuredValueNormalized =
  if self == nil:
    self = cast[MeasuredValueNormalized](GLOBAL_CALLOC(1,
        sizeof(sMeasuredValueNormalized)))
  if self != nil:
    MeasuredValueNormalized_initialize(self)
    self.objectAddress = ioa
    MeasuredValueNormalized_setValue(self, value)
    self.quality = quality
  return self

proc MeasuredValueNormalized_getValue*(self: MeasuredValueNormalized): cfloat =
  var nv: cfloat = (float)(getScaledValue(self.encodedValue)) div 32767.0
  return nv

proc MeasuredValueNormalized_setValue*(self: MeasuredValueNormalized; value: cfloat) =
  if value > 1.0:
    value = 1.0
  elif value < -1.0:
    value = -1.0
  var scaledValue: cint = (int)(value * 32767.0)
  setScaledValue(self.encodedValue, scaledValue)

proc MeasuredValueNormalized_getQuality*(self: MeasuredValueNormalized): QualityDescriptor =
  return self.quality

proc MeasuredValueNormalized_getFromBuffer*(self: MeasuredValueNormalized;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): MeasuredValueNormalized =
  if self == nil:
    self = cast[MeasuredValueNormalized](GLOBAL_MALLOC(
        sizeof(sMeasuredValueNormalized)))
  if self != nil:
    MeasuredValueNormalized_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
  return self

## *********************************************
##  ParameterNormalizedValue
## ********************************************

proc ParameterNormalizedValue_destroy*(self: ParameterNormalizedValue) =
  GLOBAL_FREEMEM(self)

proc ParameterNormalizedValue_create*(self: ParameterNormalizedValue; ioa: cint;
                                     value: cfloat;
                                     quality: QualifierOfParameterMV): ParameterNormalizedValue =
  var pvn: ParameterNormalizedValue = MeasuredValueNormalized_create(self, ioa, value,
      cast[QualityDescriptor](quality))
  pvn.`type` = P_ME_NA_1
  return pvn

proc ParameterNormalizedValue_getValue*(self: ParameterNormalizedValue): cfloat =
  return MeasuredValueNormalized_getValue(self)

proc ParameterNormalizedValue_setValue*(self: ParameterNormalizedValue;
                                       value: cfloat) =
  MeasuredValueNormalized_setValue(self, value)

proc ParameterNormalizedValue_getQPM*(self: ParameterNormalizedValue): QualifierOfParameterMV =
  return self.quality

proc ParameterNormalizedValue_getFromBuffer*(self: ParameterNormalizedValue;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint): ParameterNormalizedValue =
  var pvn: MeasuredValueNormalized = MeasuredValueNormalized_getFromBuffer(self,
      parameters, msg, msgSize, startIndex, false)
  pvn.`type` = P_ME_NA_1
  return cast[ParameterNormalizedValue](pvn)

## ************************************************************
##  MeasuredValueNormalizedWithoutQuality : InformationObject
## ***********************************************************

proc MeasuredValueNormalizedWithoutQuality_encode*(
    self: MeasuredValueNormalizedWithoutQuality; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 2 else: (parameters.sizeOfIOA + 2)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.encodedValue[0])
  Frame_setNextByte(frame, self.encodedValue[1])
  return true

var measuredValueNormalizedWithoutQualityVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueNormalizedWithoutQuality_encode),
    cast[DestroyFunction](MeasuredValueNormalizedWithoutQuality_destroy)]

proc MeasuredValueNormalizedWithoutQuality_initialize*(
    self: MeasuredValueNormalizedWithoutQuality) =
  self.virtualFunctionTable = addr((measuredValueNormalizedWithoutQualityVFT))
  self.`type` = M_ME_ND_1

proc MeasuredValueNormalizedWithoutQuality_destroy*(
    self: MeasuredValueNormalizedWithoutQuality) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueNormalizedWithoutQuality_create*(
    self: MeasuredValueNormalizedWithoutQuality; ioa: cint; value: cfloat): MeasuredValueNormalizedWithoutQuality =
  if self == nil:
    self = cast[MeasuredValueNormalizedWithoutQuality](GLOBAL_CALLOC(1,
        sizeof(sMeasuredValueNormalizedWithoutQuality)))
  if self != nil:
    MeasuredValueNormalizedWithoutQuality_initialize(self)
    self.objectAddress = ioa
    MeasuredValueNormalizedWithoutQuality_setValue(self, value)
  return self

proc MeasuredValueNormalizedWithoutQuality_getValue*(
    self: MeasuredValueNormalizedWithoutQuality): cfloat =
  var nv: cfloat = ((float)(getScaledValue(self.encodedValue) + 0.5) div 32767.5)
  return nv

proc MeasuredValueNormalizedWithoutQuality_setValue*(
    self: MeasuredValueNormalizedWithoutQuality; value: cfloat) =
  if value > 1.0:
    value = 1.0
  elif value < -1.0:
    value = -1.0
  var scaledValue: cint = (int)((value * 32767.5) - 0.5)
  setScaledValue(self.encodedValue, scaledValue)

proc MeasuredValueNormalizedWithoutQuality_getFromBuffer*(
    self: MeasuredValueNormalizedWithoutQuality;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): MeasuredValueNormalizedWithoutQuality =
  if self == nil:
    self = cast[MeasuredValueNormalizedWithoutQuality](GLOBAL_MALLOC(
        sizeof(sMeasuredValueNormalizedWithoutQuality)))
  if self != nil:
    MeasuredValueNormalizedWithoutQuality_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
  return self

## **********************************************************************
##  MeasuredValueNormalizedWithCP24Time2a : MeasuredValueNormalized
## *********************************************************************

proc MeasuredValueNormalizedWithCP24Time2a_encode*(
    self: MeasuredValueNormalizedWithCP24Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 6 else: (parameters.sizeOfIOA + 6)
  if Frame_getSpaceLeft(frame) < size:
    return false
  MeasuredValueNormalized_encode(cast[MeasuredValueNormalized](self), frame,
                                 parameters, isSequence)
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var measuredValueNormalizedWithCP24Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueNormalizedWithCP24Time2a_encode),
    cast[DestroyFunction](MeasuredValueNormalizedWithCP24Time2a_destroy)]

proc MeasuredValueNormalizedWithCP24Time2a_initialize*(
    self: MeasuredValueNormalizedWithCP24Time2a) =
  self.virtualFunctionTable = addr((measuredValueNormalizedWithCP24Time2aVFT))
  self.`type` = M_ME_TA_1

proc MeasuredValueNormalizedWithCP24Time2a_destroy*(
    self: MeasuredValueNormalizedWithCP24Time2a) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueNormalizedWithCP24Time2a_create*(
    self: MeasuredValueNormalizedWithCP24Time2a; ioa: cint; value: cfloat;
    quality: QualityDescriptor; timestamp: CP24Time2a): MeasuredValueNormalizedWithCP24Time2a =
  if self == nil:
    self = cast[MeasuredValueNormalizedWithCP24Time2a](GLOBAL_CALLOC(1,
        sizeof(sMeasuredValueNormalizedWithCP24Time2a)))
  if self != nil:
    MeasuredValueNormalizedWithCP24Time2a_initialize(self)
    self.objectAddress = ioa
    MeasuredValueNormalized_setValue(cast[MeasuredValueNormalized](self), value)
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc MeasuredValueNormalizedWithCP24Time2a_getTimestamp*(
    self: MeasuredValueNormalizedWithCP24Time2a): CP24Time2a =
  return addr((self.timestamp))

proc MeasuredValueNormalizedWithCP24Time2a_setTimestamp*(
    self: MeasuredValueNormalizedWithCP24Time2a; value: CP24Time2a) =
  var i: cint
  i = 0
  while i < 3:
    self.timestamp.encodedValue[i] = value.encodedValue[i]
    inc(i)

proc MeasuredValueNormalizedWithCP24Time2a_getFromBuffer*(
    self: MeasuredValueNormalizedWithCP24Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): MeasuredValueNormalizedWithCP24Time2a =
  if self == nil:
    self = cast[MeasuredValueNormalizedWithCP24Time2a](GLOBAL_MALLOC(
        sizeof(sMeasuredValueNormalizedWithCP24Time2a)))
  if self != nil:
    MeasuredValueNormalizedWithCP24Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## **********************************************************************
##  MeasuredValueNormalizedWithCP56Time2a : MeasuredValueNormalized
## *********************************************************************

proc MeasuredValueNormalizedWithCP56Time2a_encode*(
    self: MeasuredValueNormalizedWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 10 else: (parameters.sizeOfIOA + 10)
  if Frame_getSpaceLeft(frame) < size:
    return false
  MeasuredValueNormalized_encode(cast[MeasuredValueNormalized](self), frame,
                                 parameters, isSequence)
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var measuredValueNormalizedWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueNormalizedWithCP56Time2a_encode),
    cast[DestroyFunction](MeasuredValueNormalizedWithCP56Time2a_destroy)]

proc MeasuredValueNormalizedWithCP56Time2a_initialize*(
    self: MeasuredValueNormalizedWithCP56Time2a) =
  self.virtualFunctionTable = addr((measuredValueNormalizedWithCP56Time2aVFT))
  self.`type` = M_ME_TD_1

proc MeasuredValueNormalizedWithCP56Time2a_destroy*(
    self: MeasuredValueNormalizedWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueNormalizedWithCP56Time2a_create*(
    self: MeasuredValueNormalizedWithCP56Time2a; ioa: cint; value: cfloat;
    quality: QualityDescriptor; timestamp: CP56Time2a): MeasuredValueNormalizedWithCP56Time2a =
  if self == nil:
    self = cast[MeasuredValueNormalizedWithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sMeasuredValueNormalizedWithCP56Time2a)))
  if self != nil:
    MeasuredValueNormalizedWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    MeasuredValueNormalized_setValue(cast[MeasuredValueNormalized](self), value)
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc MeasuredValueNormalizedWithCP56Time2a_getTimestamp*(
    self: MeasuredValueNormalizedWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc MeasuredValueNormalizedWithCP56Time2a_setTimestamp*(
    self: MeasuredValueNormalizedWithCP56Time2a; value: CP56Time2a) =
  var i: cint
  i = 0
  while i < 7:
    self.timestamp.encodedValue[i] = value.encodedValue[i]
    inc(i)

proc MeasuredValueNormalizedWithCP56Time2a_getFromBuffer*(
    self: MeasuredValueNormalizedWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): MeasuredValueNormalizedWithCP56Time2a =
  if self == nil:
    self = cast[MeasuredValueNormalizedWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sMeasuredValueNormalizedWithCP56Time2a)))
  if self != nil:
    MeasuredValueNormalizedWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ******************************************
##  MeasuredValueScaled
## *****************************************

proc MeasuredValueScaled_encode*(self: MeasuredValueScaled; frame: Frame;
                                parameters: CS101_AppLayerParameters;
                                isSequence: bool): bool =
  return MeasuredValueNormalized_encode(cast[MeasuredValueNormalized](self),
                                       frame, parameters, isSequence)

var measuredValueScaledVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueScaled_encode),
    cast[DestroyFunction](MeasuredValueScaled_destroy)]

proc MeasuredValueScaled_initialize*(self: MeasuredValueScaled) =
  self.virtualFunctionTable = addr((measuredValueScaledVFT))
  self.`type` = M_ME_NB_1

proc MeasuredValueScaled_create*(self: MeasuredValueScaled; ioa: cint; value: cint;
                                quality: QualityDescriptor): MeasuredValueScaled =
  if self == nil:
    self = cast[MeasuredValueScaled](GLOBAL_CALLOC(1, sizeof(sMeasuredValueScaled)))
  if self != nil:
    MeasuredValueScaled_initialize(self)
    self.objectAddress = ioa
    setScaledValue(self.encodedValue, value)
    self.quality = quality
  return self

proc MeasuredValueScaled_destroy*(self: MeasuredValueScaled) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueScaled_getValue*(self: MeasuredValueScaled): cint =
  return getScaledValue(self.encodedValue)

proc MeasuredValueScaled_setValue*(self: MeasuredValueScaled; value: cint) =
  setScaledValue(self.encodedValue, value)

proc MeasuredValueScaled_getQuality*(self: MeasuredValueScaled): QualityDescriptor =
  return self.quality

proc MeasuredValueScaled_setQuality*(self: MeasuredValueScaled;
                                    quality: QualityDescriptor) =
  self.quality = quality

proc MeasuredValueScaled_getFromBuffer*(self: MeasuredValueScaled;
                                       parameters: CS101_AppLayerParameters;
                                       msg: ptr uint8_t; msgSize: cint;
                                       startIndex: cint; isSequence: bool): MeasuredValueScaled =
  if self == nil:
    self = cast[MeasuredValueScaled](GLOBAL_MALLOC(sizeof(sMeasuredValueScaled)))
  if self != nil:
    MeasuredValueScaled_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
  return self

## *****************************************************
##  ParameterScaledValue : MeasuredValueScaled
## ***************************************************

proc ParameterScaledValue_destroy*(self: ParameterScaledValue) =
  GLOBAL_FREEMEM(self)

proc ParameterScaledValue_create*(self: ParameterScaledValue; ioa: cint; value: cint;
                                 qpm: QualifierOfParameterMV): ParameterScaledValue =
  var pvn: ParameterScaledValue = MeasuredValueScaled_create(self, ioa, value, qpm)
  pvn.`type` = P_ME_NB_1
  return pvn

proc ParameterScaledValue_getValue*(self: ParameterScaledValue): cint =
  return getScaledValue(self.encodedValue)

proc ParameterScaledValue_setValue*(self: ParameterScaledValue; value: cint) =
  setScaledValue(self.encodedValue, value)

proc ParameterScaledValue_getQPM*(self: ParameterScaledValue): QualifierOfParameterMV =
  return self.quality

proc ParameterScaledValue_getFromBuffer*(self: ParameterScaledValue;
                                        parameters: CS101_AppLayerParameters;
                                        msg: ptr uint8_t; msgSize: cint;
                                        startIndex: cint): ParameterScaledValue =
  var psv: MeasuredValueScaled = MeasuredValueScaled_getFromBuffer(self, parameters,
      msg, msgSize, startIndex, false)
  psv.`type` = P_ME_NB_1
  return cast[ParameterScaledValue](psv)

## ******************************************
##  MeasuredValueScaledWithCP24Time2a
## *****************************************

proc MeasuredValueScaledWithCP24Time2a_encode*(
    self: MeasuredValueScaledWithCP24Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 6 else: (parameters.sizeOfIOA + 6)
  if Frame_getSpaceLeft(frame) < size:
    return false
  MeasuredValueNormalized_encode(cast[MeasuredValueNormalized](self), frame,
                                 parameters, isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var measuredValueScaledWithCP24Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueScaledWithCP24Time2a_encode),
    cast[DestroyFunction](MeasuredValueScaled_destroy)]

proc MeasuredValueScaledWithCP24Time2a_initialize*(
    self: MeasuredValueScaledWithCP24Time2a) =
  self.virtualFunctionTable = addr((measuredValueScaledWithCP24Time2aVFT))
  self.`type` = M_ME_TB_1

proc MeasuredValueScaledWithCP24Time2a_destroy*(
    self: MeasuredValueScaledWithCP24Time2a) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueScaledWithCP24Time2a_create*(
    self: MeasuredValueScaledWithCP24Time2a; ioa: cint; value: cint;
    quality: QualityDescriptor; timestamp: CP24Time2a): MeasuredValueScaledWithCP24Time2a =
  if self == nil:
    self = cast[MeasuredValueScaledWithCP24Time2a](GLOBAL_CALLOC(1,
        sizeof(sMeasuredValueScaledWithCP24Time2a)))
  if self != nil:
    MeasuredValueScaledWithCP24Time2a_initialize(self)
    self.objectAddress = ioa
    setScaledValue(self.encodedValue, value)
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc MeasuredValueScaledWithCP24Time2a_getTimestamp*(
    self: MeasuredValueScaledWithCP24Time2a): CP24Time2a =
  return addr((self.timestamp))

proc MeasuredValueScaledWithCP24Time2a_setTimestamp*(
    self: MeasuredValueScaledWithCP24Time2a; value: CP24Time2a) =
  var i: cint
  i = 0
  while i < 3:
    self.timestamp.encodedValue[i] = value.encodedValue[i]
    inc(i)

proc MeasuredValueScaledWithCP24Time2a_getFromBuffer*(
    self: MeasuredValueScaledWithCP24Time2a; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint; isSequence: bool): MeasuredValueScaledWithCP24Time2a =
  if self == nil:
    self = cast[MeasuredValueScaledWithCP24Time2a](GLOBAL_MALLOC(
        sizeof(sMeasuredValueScaledWithCP24Time2a)))
  if self != nil:
    MeasuredValueScaledWithCP24Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ******************************************
##  MeasuredValueScaledWithCP56Time2a
## *****************************************

proc MeasuredValueScaledWithCP56Time2a_encode*(
    self: MeasuredValueScaledWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 10 else: (parameters.sizeOfIOA + 10)
  if Frame_getSpaceLeft(frame) < size:
    return false
  MeasuredValueNormalized_encode(cast[MeasuredValueNormalized](self), frame,
                                 parameters, isSequence)
  ##  timestamp
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var measuredValueScaledWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueScaledWithCP56Time2a_encode),
    cast[DestroyFunction](MeasuredValueScaledWithCP56Time2a_destroy)]

proc MeasuredValueScaledWithCP56Time2a_initialize*(
    self: MeasuredValueScaledWithCP56Time2a) =
  self.virtualFunctionTable = addr(measuredValueScaledWithCP56Time2aVFT)
  self.`type` = M_ME_TE_1

proc MeasuredValueScaledWithCP56Time2a_destroy*(
    self: MeasuredValueScaledWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueScaledWithCP56Time2a_create*(
    self: MeasuredValueScaledWithCP56Time2a; ioa: cint; value: cint;
    quality: QualityDescriptor; timestamp: CP56Time2a): MeasuredValueScaledWithCP56Time2a =
  if self == nil:
    self = cast[MeasuredValueScaledWithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sMeasuredValueScaledWithCP56Time2a)))
  if self != nil:
    MeasuredValueScaledWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    setScaledValue(self.encodedValue, value)
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc MeasuredValueScaledWithCP56Time2a_getTimestamp*(
    self: MeasuredValueScaledWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc MeasuredValueScaledWithCP56Time2a_setTimestamp*(
    self: MeasuredValueScaledWithCP56Time2a; value: CP56Time2a) =
  var i: cint
  i = 0
  while i < 7:
    self.timestamp.encodedValue[i] = value.encodedValue[i]
    inc(i)

proc MeasuredValueScaledWithCP56Time2a_getFromBuffer*(
    self: MeasuredValueScaledWithCP56Time2a; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint; isSequence: bool): MeasuredValueScaledWithCP56Time2a =
  if self == nil:
    self = cast[MeasuredValueScaledWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sMeasuredValueScaledWithCP56Time2a)))
  if self != nil:
    MeasuredValueScaledWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ******************************************
##  MeasuredValueShort
## *****************************************

proc MeasuredValueShort_encode*(self: MeasuredValueShort; frame: Frame;
                               parameters: CS101_AppLayerParameters;
                               isSequence: bool): bool =
  var size: cint = if isSequence: 5 else: (parameters.sizeOfIOA + 5)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
  when (ORDER_LITTLE_ENDIAN == 1):
    Frame_appendBytes(frame, valueBytes, 4)
  else:
    Frame_setNextByte(frame, valueBytes[3])
    Frame_setNextByte(frame, valueBytes[2])
    Frame_setNextByte(frame, valueBytes[1])
    Frame_setNextByte(frame, valueBytes[0])
  Frame_setNextByte(frame, cast[uint8_t](self.quality))
  return true

var measuredValueShortVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueShort_encode),
    cast[DestroyFunction](MeasuredValueShort_destroy)]

proc MeasuredValueShort_initialize*(self: MeasuredValueShort) =
  self.virtualFunctionTable = addr((measuredValueShortVFT))
  self.`type` = M_ME_NC_1

proc MeasuredValueShort_destroy*(self: MeasuredValueShort) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueShort_create*(self: MeasuredValueShort; ioa: cint; value: cfloat;
                               quality: QualityDescriptor): MeasuredValueShort =
  if self == nil:
    self = cast[MeasuredValueShort](GLOBAL_CALLOC(1, sizeof(sMeasuredValueShort)))
  if self != nil:
    MeasuredValueShort_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.quality = quality
  return self

proc MeasuredValueShort_getValue*(self: MeasuredValueShort): cfloat =
  return self.value

proc MeasuredValueShort_setValue*(self: MeasuredValueShort; value: cfloat) =
  self.value = value

proc MeasuredValueShort_getQuality*(self: MeasuredValueShort): QualityDescriptor =
  return self.quality

proc MeasuredValueShort_getFromBuffer*(self: MeasuredValueShort;
                                      parameters: CS101_AppLayerParameters;
                                      msg: ptr uint8_t; msgSize: cint;
                                      startIndex: cint; isSequence: bool): MeasuredValueShort =
  if self == nil:
    self = cast[MeasuredValueShort](GLOBAL_MALLOC(sizeof(sMeasuredValueShort)))
  if self != nil:
    MeasuredValueShort_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
    when (ORDER_LITTLE_ENDIAN == 1):
      valueBytes[0] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[3] = msg[inc(startIndex)]
    else:
      valueBytes[3] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[0] = msg[inc(startIndex)]
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
  return self

## *****************************************************
##  ParameterFloatValue : MeasuredValueShort
## ***************************************************

proc ParameterFloatValue_destroy*(self: ParameterFloatValue) =
  GLOBAL_FREEMEM(self)

proc ParameterFloatValue_create*(self: ParameterFloatValue; ioa: cint; value: cfloat;
                                qpm: QualifierOfParameterMV): ParameterFloatValue =
  var pvf: ParameterFloatValue = MeasuredValueShort_create(self, ioa, value,
      cast[QualityDescriptor](qpm))
  pvf.`type` = P_ME_NC_1
  return pvf

proc ParameterFloatValue_getValue*(self: ParameterFloatValue): cfloat =
  return self.value

proc ParameterFloatValue_setValue*(self: ParameterFloatValue; value: cfloat) =
  self.value = value

proc ParameterFloatValue_getQPM*(self: ParameterFloatValue): QualifierOfParameterMV =
  return self.quality

proc ParameterFloatValue_getFromBuffer*(self: ParameterFloatValue;
                                       parameters: CS101_AppLayerParameters;
                                       msg: ptr uint8_t; msgSize: cint;
                                       startIndex: cint): ParameterFloatValue =
  var psv: ParameterFloatValue = MeasuredValueShort_getFromBuffer(self, parameters,
      msg, msgSize, startIndex, false)
  psv.`type` = P_ME_NC_1
  return cast[ParameterFloatValue](psv)

## ******************************************
##  MeasuredValueFloatWithCP24Time2a
## *****************************************

proc MeasuredValueShortWithCP24Time2a_encode*(
    self: MeasuredValueShortWithCP24Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 8 else: (parameters.sizeOfIOA + 8)
  if Frame_getSpaceLeft(frame) < size:
    return false
  MeasuredValueShort_encode(cast[MeasuredValueShort](self), frame, parameters,
                            isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var measuredValueShortWithCP24Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueShortWithCP24Time2a_encode),
    cast[DestroyFunction](MeasuredValueShortWithCP24Time2a_destroy)]

proc MeasuredValueShortWithCP24Time2a_initialize*(
    self: MeasuredValueShortWithCP24Time2a) =
  self.virtualFunctionTable = addr((measuredValueShortWithCP24Time2aVFT))
  self.`type` = M_ME_TC_1

proc MeasuredValueShortWithCP24Time2a_destroy*(
    self: MeasuredValueShortWithCP24Time2a) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueShortWithCP24Time2a_create*(
    self: MeasuredValueShortWithCP24Time2a; ioa: cint; value: cfloat;
    quality: QualityDescriptor; timestamp: CP24Time2a): MeasuredValueShortWithCP24Time2a =
  if self == nil:
    self = cast[MeasuredValueShortWithCP24Time2a](GLOBAL_CALLOC(1,
        sizeof(sMeasuredValueShortWithCP24Time2a)))
  if self != nil:
    MeasuredValueShortWithCP24Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc MeasuredValueShortWithCP24Time2a_getTimestamp*(
    self: MeasuredValueShortWithCP24Time2a): CP24Time2a =
  return addr((self.timestamp))

proc MeasuredValueShortWithCP24Time2a_setTimestamp*(
    self: MeasuredValueShortWithCP24Time2a; value: CP24Time2a) =
  var i: cint
  i = 0
  while i < 3:
    self.timestamp.encodedValue[i] = value.encodedValue[i]
    inc(i)

proc MeasuredValueShortWithCP24Time2a_getFromBuffer*(
    self: MeasuredValueShortWithCP24Time2a; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint; isSequence: bool): MeasuredValueShortWithCP24Time2a =
  if self == nil:
    self = cast[MeasuredValueShortWithCP24Time2a](GLOBAL_MALLOC(
        sizeof(sMeasuredValueShortWithCP24Time2a)))
  if self != nil:
    MeasuredValueShortWithCP24Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
    when (ORDER_LITTLE_ENDIAN == 1):
      valueBytes[0] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[3] = msg[inc(startIndex)]
    else:
      valueBytes[3] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[0] = msg[inc(startIndex)]
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ******************************************
##  MeasuredValueFloatWithCP56Time2a
## *****************************************

proc MeasuredValueShortWithCP56Time2a_encode*(
    self: MeasuredValueShortWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 12 else: (parameters.sizeOfIOA + 12)
  if Frame_getSpaceLeft(frame) < size:
    return false
  MeasuredValueShort_encode(cast[MeasuredValueShort](self), frame, parameters,
                            isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var measuredValueShortWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](MeasuredValueShortWithCP56Time2a_encode),
    cast[DestroyFunction](MeasuredValueShortWithCP56Time2a_destroy)]

proc MeasuredValueShortWithCP56Time2a_initialize*(
    self: MeasuredValueShortWithCP56Time2a) =
  self.virtualFunctionTable = addr((measuredValueShortWithCP56Time2aVFT))
  self.`type` = M_ME_TF_1

proc MeasuredValueShortWithCP56Time2a_destroy*(
    self: MeasuredValueShortWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc MeasuredValueShortWithCP56Time2a_create*(
    self: MeasuredValueShortWithCP56Time2a; ioa: cint; value: cfloat;
    quality: QualityDescriptor; timestamp: CP56Time2a): MeasuredValueShortWithCP56Time2a =
  if self == nil:
    self = cast[MeasuredValueShortWithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sMeasuredValueShortWithCP56Time2a)))
  if self != nil:
    MeasuredValueShortWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.quality = quality
    self.timestamp = timestamp[]
  return self

proc MeasuredValueShortWithCP56Time2a_getTimestamp*(
    self: MeasuredValueShortWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc MeasuredValueShortWithCP56Time2a_setTimestamp*(
    self: MeasuredValueShortWithCP56Time2a; value: CP56Time2a) =
  var i: cint
  i = 0
  while i < 7:
    self.timestamp.encodedValue[i] = value.encodedValue[i]
    inc(i)

proc MeasuredValueShortWithCP56Time2a_getFromBuffer*(
    self: MeasuredValueShortWithCP56Time2a; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint; isSequence: bool): MeasuredValueShortWithCP56Time2a =
  if self == nil:
    self = cast[MeasuredValueShortWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sMeasuredValueShortWithCP56Time2a)))
  if self != nil:
    MeasuredValueShortWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
    when (ORDER_LITTLE_ENDIAN == 1):
      valueBytes[0] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[3] = msg[inc(startIndex)]
    else:
      valueBytes[3] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[0] = msg[inc(startIndex)]
    ##  quality
    self.quality = cast[QualityDescriptor](msg[inc(startIndex)])
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ******************************************
##  IntegratedTotals
## *****************************************

proc IntegratedTotals_encode*(self: IntegratedTotals; frame: Frame;
                             parameters: CS101_AppLayerParameters;
                             isSequence: bool): bool =
  var size: cint = if isSequence: 5 else: (parameters.sizeOfIOA + 5)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_appendBytes(frame, self.totals.encodedValue, 5)
  return true

var integratedTotalsVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](IntegratedTotals_encode),
    cast[DestroyFunction](IntegratedTotals_destroy)]

proc IntegratedTotals_initialize*(self: IntegratedTotals) =
  self.virtualFunctionTable = addr((integratedTotalsVFT))
  self.`type` = M_IT_NA_1

proc IntegratedTotals_destroy*(self: IntegratedTotals) =
  GLOBAL_FREEMEM(self)

proc IntegratedTotals_create*(self: IntegratedTotals; ioa: cint;
                             value: BinaryCounterReading): IntegratedTotals =
  if self == nil:
    self = cast[IntegratedTotals](GLOBAL_CALLOC(1, sizeof(sIntegratedTotals)))
  if self != nil:
    IntegratedTotals_initialize(self)
    self.objectAddress = ioa
    self.totals = value[]
  return self

proc IntegratedTotals_getBCR*(self: IntegratedTotals): BinaryCounterReading =
  return addr((self.totals))

proc IntegratedTotals_setBCR*(self: IntegratedTotals; value: BinaryCounterReading) =
  var i: cint
  i = 0
  while i < 5:
    self.totals.encodedValue[i] = value.encodedValue[i]
    inc(i)

proc IntegratedTotals_getFromBuffer*(self: IntegratedTotals;
                                    parameters: CS101_AppLayerParameters;
                                    msg: ptr uint8_t; msgSize: cint;
                                    startIndex: cint; isSequence: bool): IntegratedTotals =
  if self == nil:
    self = cast[IntegratedTotals](GLOBAL_MALLOC(sizeof(sIntegratedTotals)))
  if self != nil:
    IntegratedTotals_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var i: cint = 0
    i = 0
    while i < 5:
      self.totals.encodedValue[i] = msg[inc(startIndex)]
      inc(i)
  return self

## **********************************************************************
##  IntegratedTotalsWithCP24Time2a : IntegratedTotals
## *********************************************************************

proc IntegratedTotalsWithCP24Time2a_encode*(self: IntegratedTotalsWithCP24Time2a;
    frame: Frame; parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 8 else: (parameters.sizeOfIOA + 8)
  if Frame_getSpaceLeft(frame) < size:
    return false
  IntegratedTotals_encode(cast[IntegratedTotals](self), frame, parameters,
                          isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var integratedTotalsWithCP24Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](IntegratedTotalsWithCP24Time2a_encode),
    cast[DestroyFunction](IntegratedTotalsWithCP24Time2a_destroy)]

proc IntegratedTotalsWithCP24Time2a_initialize*(
    self: IntegratedTotalsWithCP24Time2a) =
  self.virtualFunctionTable = addr((integratedTotalsWithCP24Time2aVFT))
  self.`type` = M_IT_TA_1

proc IntegratedTotalsWithCP24Time2a_destroy*(self: IntegratedTotalsWithCP24Time2a) =
  GLOBAL_FREEMEM(self)

proc IntegratedTotalsWithCP24Time2a_create*(self: IntegratedTotalsWithCP24Time2a;
    ioa: cint; value: BinaryCounterReading; timestamp: CP24Time2a): IntegratedTotalsWithCP24Time2a =
  if self == nil:
    self = cast[IntegratedTotalsWithCP24Time2a](GLOBAL_CALLOC(1,
        sizeof(sIntegratedTotalsWithCP24Time2a)))
  if self != nil:
    IntegratedTotalsWithCP24Time2a_initialize(self)
    self.objectAddress = ioa
    self.totals = value[]
    self.timestamp = timestamp[]
  return self

proc IntegratedTotalsWithCP24Time2a_getTimestamp*(
    self: IntegratedTotalsWithCP24Time2a): CP24Time2a =
  return addr((self.timestamp))

proc IntegratedTotalsWithCP24Time2a_setTimestamp*(
    self: IntegratedTotalsWithCP24Time2a; value: CP24Time2a) =
  var i: cint
  i = 0
  while i < 3:
    self.timestamp.encodedValue[i] = value.encodedValue[i]
    inc(i)

proc IntegratedTotalsWithCP24Time2a_getFromBuffer*(
    self: IntegratedTotalsWithCP24Time2a; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint; isSequence: bool): IntegratedTotalsWithCP24Time2a =
  if self == nil:
    self = cast[IntegratedTotalsWithCP24Time2a](GLOBAL_MALLOC(
        sizeof(sIntegratedTotalsWithCP24Time2a)))
  if self != nil:
    IntegratedTotalsWithCP24Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var i: cint = 0
    i = 0
    while i < 5:
      self.totals.encodedValue[i] = msg[inc(startIndex)]
      inc(i)
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## **********************************************************************
##  IntegratedTotalsWithCP56Time2a : IntegratedTotals
## *********************************************************************

proc IntegratedTotalsWithCP56Time2a_encode*(self: IntegratedTotalsWithCP56Time2a;
    frame: Frame; parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 12 else: (parameters.sizeOfIOA + 12)
  if Frame_getSpaceLeft(frame) < size:
    return false
  IntegratedTotals_encode(cast[IntegratedTotals](self), frame, parameters,
                          isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var integratedTotalsWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](IntegratedTotalsWithCP56Time2a_encode),
    cast[DestroyFunction](IntegratedTotalsWithCP56Time2a_destroy)]

proc IntegratedTotalsWithCP56Time2a_initialize*(
    self: IntegratedTotalsWithCP56Time2a) =
  self.virtualFunctionTable = addr((integratedTotalsWithCP56Time2aVFT))
  self.`type` = M_IT_TB_1

proc IntegratedTotalsWithCP56Time2a_destroy*(self: IntegratedTotalsWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc IntegratedTotalsWithCP56Time2a_create*(self: IntegratedTotalsWithCP56Time2a;
    ioa: cint; value: BinaryCounterReading; timestamp: CP56Time2a): IntegratedTotalsWithCP56Time2a =
  if self == nil:
    self = cast[IntegratedTotalsWithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sIntegratedTotalsWithCP56Time2a)))
  if self != nil:
    IntegratedTotalsWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.totals = value[]
    self.timestamp = timestamp[]
  return self

proc IntegratedTotalsWithCP56Time2a_getTimestamp*(
    self: IntegratedTotalsWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc IntegratedTotalsWithCP56Time2a_setTimestamp*(
    self: IntegratedTotalsWithCP56Time2a; value: CP56Time2a) =
  var i: cint
  i = 0
  while i < 7:
    self.timestamp.encodedValue[i] = value.encodedValue[i]
    inc(i)

proc IntegratedTotalsWithCP56Time2a_getFromBuffer*(
    self: IntegratedTotalsWithCP56Time2a; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint; isSequence: bool): IntegratedTotalsWithCP56Time2a =
  if self == nil:
    self = cast[IntegratedTotalsWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sIntegratedTotalsWithCP56Time2a)))
  if self != nil:
    IntegratedTotalsWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    var i: cint = 0
    i = 0
    while i < 5:
      self.totals.encodedValue[i] = msg[inc(startIndex)]
      inc(i)
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## **********************************************************************
##  EventOfProtectionEquipment : InformationObject
## *********************************************************************

proc EventOfProtectionEquipment_encode*(self: EventOfProtectionEquipment;
                                       frame: Frame;
                                       parameters: CS101_AppLayerParameters;
                                       isSequence: bool): bool =
  var size: cint = if isSequence: 6 else: (parameters.sizeOfIOA + 6)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, cast[uint8_t](self.event))
  Frame_appendBytes(frame, self.elapsedTime.encodedValue, 2)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var eventOfProtectionEquipmentVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](EventOfProtectionEquipment_encode),
    cast[DestroyFunction](EventOfProtectionEquipment_destroy)]

proc EventOfProtectionEquipment_initialize*(self: EventOfProtectionEquipment) =
  self.virtualFunctionTable = addr((eventOfProtectionEquipmentVFT))
  self.`type` = M_EP_TA_1

proc EventOfProtectionEquipment_destroy*(self: EventOfProtectionEquipment) =
  GLOBAL_FREEMEM(self)

proc EventOfProtectionEquipment_create*(self: EventOfProtectionEquipment;
                                       ioa: cint; event: SingleEvent;
                                       elapsedTime: CP16Time2a;
                                       timestamp: CP24Time2a): EventOfProtectionEquipment =
  if self == nil:
    self = cast[EventOfProtectionEquipment](GLOBAL_CALLOC(1,
        sizeof(sEventOfProtectionEquipment)))
  if self != nil:
    EventOfProtectionEquipment_initialize(self)
    self.objectAddress = ioa
    self.event = event[]
    self.elapsedTime = elapsedTime[]
    self.timestamp = timestamp[]
  return self

proc EventOfProtectionEquipment_getFromBuffer*(self: EventOfProtectionEquipment;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): EventOfProtectionEquipment =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 6):
    return nil
  if self == nil:
    self = cast[EventOfProtectionEquipment](GLOBAL_MALLOC(
        sizeof(sEventOfProtectionEquipment)))
  if self != nil:
    EventOfProtectionEquipment_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.event = msg[inc(startIndex)]
    ##  elapsed time
    CP16Time2a_getFromBuffer(addr((self.elapsedTime)), msg, msgSize, startIndex)
    inc(startIndex, 2)
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

proc EventOfProtectionEquipment_getEvent*(self: EventOfProtectionEquipment): SingleEvent =
  return addr((self.event))

proc EventOfProtectionEquipment_getElapsedTime*(self: EventOfProtectionEquipment): CP16Time2a =
  return addr((self.elapsedTime))

proc EventOfProtectionEquipment_getTimestamp*(self: EventOfProtectionEquipment): CP24Time2a =
  return addr((self.timestamp))

## **********************************************************************
##  EventOfProtectionEquipmentWithCP56Time2a : InformationObject
## *********************************************************************

proc EventOfProtectionEquipmentWithCP56Time2a_encode*(
    self: EventOfProtectionEquipmentWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 10 else: (parameters.sizeOfIOA + 10)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, cast[uint8_t](self.event))
  Frame_appendBytes(frame, self.elapsedTime.encodedValue, 2)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var eventOfProtectionEquipmentWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](EventOfProtectionEquipmentWithCP56Time2a_encode),
    cast[DestroyFunction](EventOfProtectionEquipmentWithCP56Time2a_destroy)]

proc EventOfProtectionEquipmentWithCP56Time2a_initialize*(
    self: EventOfProtectionEquipmentWithCP56Time2a) =
  self.virtualFunctionTable = addr((eventOfProtectionEquipmentWithCP56Time2aVFT))
  self.`type` = M_EP_TD_1

proc EventOfProtectionEquipmentWithCP56Time2a_destroy*(
    self: EventOfProtectionEquipmentWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc EventOfProtectionEquipmentWithCP56Time2a_create*(
    self: EventOfProtectionEquipmentWithCP56Time2a; ioa: cint; event: SingleEvent;
    elapsedTime: CP16Time2a; timestamp: CP56Time2a): EventOfProtectionEquipmentWithCP56Time2a =
  if self == nil:
    self = cast[EventOfProtectionEquipmentWithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sEventOfProtectionEquipmentWithCP56Time2a)))
  if self != nil:
    EventOfProtectionEquipmentWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.event = event[]
    self.elapsedTime = elapsedTime[]
    self.timestamp = timestamp[]
  return self

proc EventOfProtectionEquipmentWithCP56Time2a_getEvent*(
    self: EventOfProtectionEquipmentWithCP56Time2a): SingleEvent =
  return addr((self.event))

proc EventOfProtectionEquipmentWithCP56Time2a_getElapsedTime*(
    self: EventOfProtectionEquipmentWithCP56Time2a): CP16Time2a =
  return addr((self.elapsedTime))

proc EventOfProtectionEquipmentWithCP56Time2a_getTimestamp*(
    self: EventOfProtectionEquipmentWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc EventOfProtectionEquipmentWithCP56Time2a_getFromBuffer*(
    self: EventOfProtectionEquipmentWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): EventOfProtectionEquipmentWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 10):
    return nil
  if self == nil:
    self = cast[EventOfProtectionEquipmentWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sEventOfProtectionEquipmentWithCP56Time2a)))
  if self != nil:
    EventOfProtectionEquipmentWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.event = msg[inc(startIndex)]
    ##  elapsed time
    CP16Time2a_getFromBuffer(addr((self.elapsedTime)), msg, msgSize, startIndex)
    inc(startIndex, 2)
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## **********************************************************************
##  PackedStartEventsOfProtectionEquipment : InformationObject
## *********************************************************************

proc PackedStartEventsOfProtectionEquipment_encode*(
    self: PackedStartEventsOfProtectionEquipment; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 7 else: (parameters.sizeOfIOA + 7)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, cast[uint8_t](self.event))
  Frame_setNextByte(frame, cast[uint8_t](self.qdp))
  Frame_appendBytes(frame, self.elapsedTime.encodedValue, 2)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var packedStartEventsOfProtectionEquipmentVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](PackedStartEventsOfProtectionEquipment_encode),
    cast[DestroyFunction](PackedStartEventsOfProtectionEquipment_destroy)]

proc PackedStartEventsOfProtectionEquipment_initialize*(
    self: PackedStartEventsOfProtectionEquipment) =
  self.virtualFunctionTable = addr((packedStartEventsOfProtectionEquipmentVFT))
  self.`type` = M_EP_TB_1

proc PackedStartEventsOfProtectionEquipment_destroy*(
    self: PackedStartEventsOfProtectionEquipment) =
  GLOBAL_FREEMEM(self)

proc PackedStartEventsOfProtectionEquipment_create*(
    self: PackedStartEventsOfProtectionEquipment; ioa: cint; event: StartEvent;
    qdp: QualityDescriptorP; elapsedTime: CP16Time2a; timestamp: CP24Time2a): PackedStartEventsOfProtectionEquipment =
  if self == nil:
    self = cast[PackedStartEventsOfProtectionEquipment](GLOBAL_CALLOC(1,
        sizeof(sPackedStartEventsOfProtectionEquipment)))
  if self != nil:
    PackedStartEventsOfProtectionEquipment_initialize(self)
    self.objectAddress = ioa
    self.event = event
    self.qdp = qdp
    self.elapsedTime = elapsedTime[]
    self.timestamp = timestamp[]
  return self

proc PackedStartEventsOfProtectionEquipment_getEvent*(
    self: PackedStartEventsOfProtectionEquipment): StartEvent =
  return self.event

proc PackedStartEventsOfProtectionEquipment_getQuality*(
    self: PackedStartEventsOfProtectionEquipment): QualityDescriptorP =
  return self.qdp

proc PackedStartEventsOfProtectionEquipment_getElapsedTime*(
    self: PackedStartEventsOfProtectionEquipment): CP16Time2a =
  return addr((self.elapsedTime))

proc PackedStartEventsOfProtectionEquipment_getTimestamp*(
    self: PackedStartEventsOfProtectionEquipment): CP24Time2a =
  return addr((self.timestamp))

proc PackedStartEventsOfProtectionEquipment_getFromBuffer*(
    self: PackedStartEventsOfProtectionEquipment;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): PackedStartEventsOfProtectionEquipment =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 7):
    return nil
  if self == nil:
    self = cast[PackedStartEventsOfProtectionEquipment](GLOBAL_MALLOC(
        sizeof(sPackedStartEventsOfProtectionEquipment)))
  if self != nil:
    PackedStartEventsOfProtectionEquipment_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.event = msg[inc(startIndex)]
    ##  qdp
    self.qdp = msg[inc(startIndex)]
    ##  elapsed time
    CP16Time2a_getFromBuffer(addr((self.elapsedTime)), msg, msgSize, startIndex)
    inc(startIndex, 2)
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## **************************************************************************
##  PackedStartEventsOfProtectionEquipmentWithCP56Time2a : InformationObject
## *************************************************************************

proc PackedStartEventsOfProtectionEquipmentWithCP56Time2a_encode*(
    self: PackedStartEventsOfProtectionEquipmentWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 11 else: (parameters.sizeOfIOA + 11)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, cast[uint8_t](self.event))
  Frame_setNextByte(frame, cast[uint8_t](self.qdp))
  Frame_appendBytes(frame, self.elapsedTime.encodedValue, 2)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var packedStartEventsOfProtectionEquipmentWithCP56Time2aVFT*: sInformationObjectVFT = [cast[EncodeFunction](PackedStartEventsOfProtectionEquipmentWithCP56Time2a_encode), cast[DestroyFunction](PackedStartEventsOfProtectionEquipmentWithCP56Time2a_destroy)]

proc PackedStartEventsOfProtectionEquipmentWithCP56Time2a_initialize*(
    self: PackedStartEventsOfProtectionEquipmentWithCP56Time2a) =
  self.virtualFunctionTable = addr((packedStartEventsOfProtectionEquipmentWithCP56Time2aVFT))
  self.`type` = M_EP_TE_1

proc PackedStartEventsOfProtectionEquipmentWithCP56Time2a_destroy*(
    self: PackedStartEventsOfProtectionEquipmentWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc PackedStartEventsOfProtectionEquipmentWithCP56Time2a_create*(
    self: PackedStartEventsOfProtectionEquipmentWithCP56Time2a; ioa: cint;
    event: StartEvent; qdp: QualityDescriptorP; elapsedTime: CP16Time2a;
    timestamp: CP56Time2a): PackedStartEventsOfProtectionEquipmentWithCP56Time2a =
  if self == nil:
    self = cast[PackedStartEventsOfProtectionEquipmentWithCP56Time2a](GLOBAL_CALLOC(
        1, sizeof(sPackedStartEventsOfProtectionEquipmentWithCP56Time2a)))
  if self != nil:
    PackedStartEventsOfProtectionEquipmentWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.event = event
    self.qdp = qdp
    self.elapsedTime = elapsedTime[]
    self.timestamp = timestamp[]
  return self

proc PackedStartEventsOfProtectionEquipmentWithCP56Time2a_getEvent*(
    self: PackedStartEventsOfProtectionEquipmentWithCP56Time2a): StartEvent =
  return self.event

proc PackedStartEventsOfProtectionEquipmentWithCP56Time2a_getQuality*(
    self: PackedStartEventsOfProtectionEquipmentWithCP56Time2a): QualityDescriptorP =
  return self.qdp

proc PackedStartEventsOfProtectionEquipmentWithCP56Time2a_getElapsedTime*(
    self: PackedStartEventsOfProtectionEquipmentWithCP56Time2a): CP16Time2a =
  return addr((self.elapsedTime))

proc PackedStartEventsOfProtectionEquipmentWithCP56Time2a_getTimestamp*(
    self: PackedStartEventsOfProtectionEquipmentWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc PackedStartEventsOfProtectionEquipmentWithCP56Time2a_getFromBuffer*(
    self: PackedStartEventsOfProtectionEquipmentWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): PackedStartEventsOfProtectionEquipmentWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 7):
    return nil
  if self == nil:
    self = cast[PackedStartEventsOfProtectionEquipmentWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sPackedStartEventsOfProtectionEquipmentWithCP56Time2a)))
  if self != nil:
    PackedStartEventsOfProtectionEquipmentWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.event = msg[inc(startIndex)]
    ##  qdp
    self.qdp = msg[inc(startIndex)]
    ##  elapsed time
    CP16Time2a_getFromBuffer(addr((self.elapsedTime)), msg, msgSize, startIndex)
    inc(startIndex, 2)
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## **********************************************************************
##  PacketOutputCircuitInfo : InformationObject
## *********************************************************************

proc PacketOutputCircuitInfo_encode*(self: PackedOutputCircuitInfo; frame: Frame;
                                    parameters: CS101_AppLayerParameters;
                                    isSequence: bool): bool =
  var size: cint = if isSequence: 7 else: (parameters.sizeOfIOA + 7)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, cast[uint8_t](self.oci))
  Frame_setNextByte(frame, cast[uint8_t](self.qdp))
  Frame_appendBytes(frame, self.operatingTime.encodedValue, 2)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 3)
  return true

var packedOutputCircuitInfoVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](PacketOutputCircuitInfo_encode),
    cast[DestroyFunction](PackedOutputCircuitInfo_destroy)]

proc PacketOutputCircuitInfo_initialize*(self: PackedOutputCircuitInfo) =
  self.virtualFunctionTable = addr((packedOutputCircuitInfoVFT))
  self.`type` = M_EP_TC_1

proc PackedOutputCircuitInfo_destroy*(self: PackedOutputCircuitInfo) =
  GLOBAL_FREEMEM(self)

proc PackedOutputCircuitInfo_create*(self: PackedOutputCircuitInfo; ioa: cint;
                                    oci: OutputCircuitInfo;
                                    qdp: QualityDescriptorP;
                                    operatingTime: CP16Time2a;
                                    timestamp: CP24Time2a): PackedOutputCircuitInfo =
  if self == nil:
    self = cast[PackedOutputCircuitInfo](GLOBAL_CALLOC(1,
        sizeof(sPackedOutputCircuitInfo)))
  if self:
    PacketOutputCircuitInfo_initialize(self)
    self.objectAddress = ioa
    self.oci = oci
    self.qdp = qdp
    self.operatingTime = operatingTime[]
    self.timestamp = timestamp[]
  return self

proc PackedOutputCircuitInfo_getOCI*(self: PackedOutputCircuitInfo): OutputCircuitInfo =
  return self.oci

proc PackedOutputCircuitInfo_getQuality*(self: PackedOutputCircuitInfo): QualityDescriptorP =
  return self.qdp

proc PackedOutputCircuitInfo_getOperatingTime*(self: PackedOutputCircuitInfo): CP16Time2a =
  return addr((self.operatingTime))

proc PackedOutputCircuitInfo_getTimestamp*(self: PackedOutputCircuitInfo): CP24Time2a =
  return addr((self.timestamp))

proc PackedOutputCircuitInfo_getFromBuffer*(self: PackedOutputCircuitInfo;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): PackedOutputCircuitInfo =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 7):
    return nil
  if self == nil:
    self = cast[PackedOutputCircuitInfo](GLOBAL_MALLOC(
        sizeof(sPackedOutputCircuitInfo)))
  if self != nil:
    PacketOutputCircuitInfo_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.oci = msg[inc(startIndex)]
    ##  qdp
    self.qdp = msg[inc(startIndex)]
    ##  operating time
    CP16Time2a_getFromBuffer(addr((self.operatingTime)), msg, msgSize, startIndex)
    inc(startIndex, 2)
    ##  timestamp
    CP24Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## **********************************************************************
##  PackedOutputCircuitInfoWithCP56Time2a : InformationObject
## *********************************************************************

proc PackedOutputCircuitInfoWithCP56Time2a_encode*(
    self: PackedOutputCircuitInfoWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 11 else: (parameters.sizeOfIOA + 11)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, cast[uint8_t](self.oci))
  Frame_setNextByte(frame, cast[uint8_t](self.qdp))
  Frame_appendBytes(frame, self.operatingTime.encodedValue, 2)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var packedOutputCircuitInfoWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](PackedOutputCircuitInfoWithCP56Time2a_encode),
    cast[DestroyFunction](PackedOutputCircuitInfoWithCP56Time2a_destroy)]

proc PackedOutputCircuitInfoWithCP56Time2a_initialize*(
    self: PackedOutputCircuitInfoWithCP56Time2a) =
  self.virtualFunctionTable = addr((packedOutputCircuitInfoWithCP56Time2aVFT))
  self.`type` = M_EP_TF_1

proc PackedOutputCircuitInfoWithCP56Time2a_destroy*(
    self: PackedOutputCircuitInfoWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc PackedOutputCircuitInfoWithCP56Time2a_create*(
    self: PackedOutputCircuitInfoWithCP56Time2a; ioa: cint; oci: OutputCircuitInfo;
    qdp: QualityDescriptorP; operatingTime: CP16Time2a; timestamp: CP56Time2a): PackedOutputCircuitInfoWithCP56Time2a =
  if self == nil:
    self = cast[PackedOutputCircuitInfoWithCP56Time2a](GLOBAL_CALLOC(1,
        sizeof(sPackedOutputCircuitInfoWithCP56Time2a)))
  if self:
    PackedOutputCircuitInfoWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.oci = oci
    self.qdp = qdp
    self.operatingTime = operatingTime[]
    self.timestamp = timestamp[]
  return self

proc PackedOutputCircuitInfoWithCP56Time2a_getOCI*(
    self: PackedOutputCircuitInfoWithCP56Time2a): OutputCircuitInfo =
  return self.oci

proc PackedOutputCircuitInfoWithCP56Time2a_getQuality*(
    self: PackedOutputCircuitInfoWithCP56Time2a): QualityDescriptorP =
  return self.qdp

proc PackedOutputCircuitInfoWithCP56Time2a_getOperatingTime*(
    self: PackedOutputCircuitInfoWithCP56Time2a): CP16Time2a =
  return addr((self.operatingTime))

proc PackedOutputCircuitInfoWithCP56Time2a_getTimestamp*(
    self: PackedOutputCircuitInfoWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc PackedOutputCircuitInfoWithCP56Time2a_getFromBuffer*(
    self: PackedOutputCircuitInfoWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): PackedOutputCircuitInfoWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 7):
    return nil
  if self == nil:
    self = cast[PackedOutputCircuitInfoWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sPackedOutputCircuitInfoWithCP56Time2a)))
  if self != nil:
    PackedOutputCircuitInfoWithCP56Time2a_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.oci = msg[inc(startIndex)]
    ##  qdp
    self.qdp = msg[inc(startIndex)]
    ##  operating time
    CP16Time2a_getFromBuffer(addr((self.operatingTime)), msg, msgSize, startIndex)
    inc(startIndex, 2)
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## **********************************************************************
##  PackedSinglePointWithSCD : InformationObject
## *********************************************************************

proc PackedSinglePointWithSCD_encode*(self: PackedSinglePointWithSCD; frame: Frame;
                                     parameters: CS101_AppLayerParameters;
                                     isSequence: bool): bool =
  var size: cint = if isSequence: 5 else: (parameters.sizeOfIOA + 5)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_appendBytes(frame, self.scd.encodedValue, 4)
  Frame_setNextByte(frame, cast[uint8_t](self.qds))
  return true

var packedSinglePointWithSCDVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](PackedSinglePointWithSCD_encode),
    cast[DestroyFunction](PackedSinglePointWithSCD_destroy)]

proc PackedSinglePointWithSCD_initialize*(self: PackedSinglePointWithSCD) =
  self.virtualFunctionTable = addr((packedSinglePointWithSCDVFT))
  self.`type` = M_PS_NA_1

proc PackedSinglePointWithSCD_destroy*(self: PackedSinglePointWithSCD) =
  GLOBAL_FREEMEM(self)

proc PackedSinglePointWithSCD_create*(self: PackedSinglePointWithSCD; ioa: cint;
                                     scd: StatusAndStatusChangeDetection;
                                     qds: QualityDescriptor): PackedSinglePointWithSCD =
  if self == nil:
    self = cast[PackedSinglePointWithSCD](GLOBAL_CALLOC(1,
        sizeof(sPackedSinglePointWithSCD)))
  if self:
    PackedSinglePointWithSCD_initialize(self)
    self.objectAddress = ioa
    self.scd = scd[]
    self.qds = qds
  return self

proc PackedSinglePointWithSCD_getQuality*(self: PackedSinglePointWithSCD): QualityDescriptor =
  return self.qds

proc PackedSinglePointWithSCD_getSCD*(self: PackedSinglePointWithSCD): StatusAndStatusChangeDetection =
  return addr((self.scd))

proc PackedSinglePointWithSCD_getFromBuffer*(self: PackedSinglePointWithSCD;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint; isSequence: bool): PackedSinglePointWithSCD =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 5):
    return nil
  if self == nil:
    self = cast[PackedSinglePointWithSCD](GLOBAL_MALLOC(
        sizeof(sPackedSinglePointWithSCD)))
  if self != nil:
    PackedSinglePointWithSCD_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.scd.encodedValue[0] = msg[inc(startIndex)]
    self.scd.encodedValue[1] = msg[inc(startIndex)]
    self.scd.encodedValue[2] = msg[inc(startIndex)]
    self.scd.encodedValue[3] = msg[inc(startIndex)]
    ##  QDS
    self.qds = msg[startIndex]
  return self

## ******************************************
##  SingleCommand
## *****************************************

proc SingleCommand_encode*(self: SingleCommand; frame: Frame;
                          parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.sco)
  return true

var singleCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SingleCommand_encode),
    cast[DestroyFunction](SingleCommand_destroy)]

proc SingleCommand_initialize*(self: SingleCommand) =
  self.virtualFunctionTable = addr((singleCommandVFT))
  self.`type` = C_SC_NA_1

proc SingleCommand_destroy*(self: SingleCommand) =
  GLOBAL_FREEMEM(self)

proc SingleCommand_create*(self: SingleCommand; ioa: cint; command: bool;
                          selectCommand: bool; qu: cint): SingleCommand =
  if self == nil:
    self = cast[SingleCommand](GLOBAL_MALLOC(sizeof(sSingleCommand)))
  if self:
    SingleCommand_initialize(self)
    self.objectAddress = ioa
    var sco: uint8_t = ((qu and 0x00000000) * 4)
    if command:
      sco = sco or 0x00000000
    if selectCommand:
      sco = sco or 0x00000000
    self.sco = sco
  return self

proc SingleCommand_getQU*(self: SingleCommand): cint =
  return (self.sco and 0x00000000) div 4

proc SingleCommand_getState*(self: SingleCommand): bool =
  return (self.sco and 0x00000000) == 0x00000000

proc SingleCommand_isSelect*(self: SingleCommand): bool =
  return (self.sco and 0x00000000) == 0x00000000

proc SingleCommand_getFromBuffer*(self: SingleCommand;
                                 parameters: CS101_AppLayerParameters;
                                 msg: ptr uint8_t; msgSize: cint; startIndex: cint): SingleCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 1):
    return nil
  if self == nil:
    self = cast[SingleCommand](GLOBAL_MALLOC(sizeof(sSingleCommand)))
  if self != nil:
    SingleCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  SCO
    self.sco = msg[startIndex]
  return self

## **********************************************************************
##  SingleCommandWithCP56Time2a : SingleCommand
## *********************************************************************

proc SingleCommandWithCP56Time2a_encode*(self: SingleCommandWithCP56Time2a;
                                        frame: Frame;
                                        parameters: CS101_AppLayerParameters;
                                        isSequence: bool): bool =
  var size: cint = if isSequence: 8 else: (parameters.sizeOfIOA + 8)
  if Frame_getSpaceLeft(frame) < size:
    return false
  SingleCommand_encode(cast[SingleCommand](self), frame, parameters, isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var singleCommandWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SingleCommandWithCP56Time2a_encode),
    cast[DestroyFunction](SingleCommandWithCP56Time2a_destroy)]

proc SingleCommandWithCP56Time2a_initialize*(self: SingleCommandWithCP56Time2a) =
  self.virtualFunctionTable = addr((singleCommandWithCP56Time2aVFT))
  self.`type` = C_SC_TA_1

proc SingleCommandWithCP56Time2a_destroy*(self: SingleCommandWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc SingleCommandWithCP56Time2a_create*(self: SingleCommandWithCP56Time2a;
                                        ioa: cint; command: bool;
                                        selectCommand: bool; qu: cint;
                                        timestamp: CP56Time2a): SingleCommandWithCP56Time2a =
  if self == nil:
    self = cast[SingleCommandWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sSingleCommandWithCP56Time2a)))
  if self:
    SingleCommandWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    var sco: uint8_t = ((qu and 0x00000000) * 4)
    if command:
      sco = sco or 0x00000000
    if selectCommand:
      sco = sco or 0x00000000
    self.sco = sco
    self.timestamp = timestamp[]
  return self

proc SingleCommandWithCP56Time2a_getTimestamp*(self: SingleCommandWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc SingleCommandWithCP56Time2a_getFromBuffer*(
    self: SingleCommandWithCP56Time2a; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint): SingleCommandWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 1):
    return nil
  if self == nil:
    self = cast[SingleCommandWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sSingleCommandWithCP56Time2a)))
  if self != nil:
    SingleCommandWithCP56Time2a_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  SCO
    self.sco = msg[inc(startIndex)]
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ******************************************
##  DoubleCommand : InformationObject
## *****************************************

proc DoubleCommand_encode*(self: DoubleCommand; frame: Frame;
                          parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.dcq)
  return true

var doubleCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](DoubleCommand_encode),
    cast[DestroyFunction](DoubleCommand_destroy)]

proc DoubleCommand_initialize*(self: DoubleCommand) =
  self.virtualFunctionTable = addr((doubleCommandVFT))
  self.`type` = C_DC_NA_1

proc DoubleCommand_destroy*(self: DoubleCommand) =
  GLOBAL_FREEMEM(self)

proc DoubleCommand_create*(self: DoubleCommand; ioa: cint; command: cint;
                          selectCommand: bool; qu: cint): DoubleCommand =
  if self == nil:
    self = cast[DoubleCommand](GLOBAL_MALLOC(sizeof(sDoubleCommand)))
  if self:
    DoubleCommand_initialize(self)
    self.objectAddress = ioa
    var dcq: uint8_t = ((qu and 0x00000000) * 4)
    inc(dcq, (uint8_t)(command and 0x00000000))
    if selectCommand:
      dcq = dcq or 0x00000000
    self.dcq = dcq
  return self

proc DoubleCommand_getQU*(self: DoubleCommand): cint =
  return (self.dcq and 0x00000000) div 4

proc DoubleCommand_getState*(self: DoubleCommand): cint =
  return self.dcq and 0x00000000

proc DoubleCommand_isSelect*(self: DoubleCommand): bool =
  return (self.dcq and 0x00000000) == 0x00000000

proc DoubleCommand_getFromBuffer*(self: DoubleCommand;
                                 parameters: CS101_AppLayerParameters;
                                 msg: ptr uint8_t; msgSize: cint; startIndex: cint): DoubleCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 1):
    return nil
  if self == nil:
    self = cast[DoubleCommand](GLOBAL_MALLOC(sizeof(sDoubleCommand)))
  if self != nil:
    DoubleCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  SCO
    self.dcq = msg[startIndex]
  return self

## *********************************************
##  DoubleCommandWithCP56Time2a : DoubleCommand
## ********************************************

proc DoubleCommandWithCP56Time2a_encode*(self: DoubleCommandWithCP56Time2a;
                                        frame: Frame;
                                        parameters: CS101_AppLayerParameters;
                                        isSequence: bool): bool =
  var size: cint = if isSequence: 8 else: (parameters.sizeOfIOA + 8)
  if Frame_getSpaceLeft(frame) < size:
    return false
  DoubleCommand_encode(cast[DoubleCommand](self), frame, parameters, isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var doubleCommandWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](DoubleCommandWithCP56Time2a_encode),
    cast[DestroyFunction](DoubleCommandWithCP56Time2a_destroy)]

proc DoubleCommandWithCP56Time2a_initialize*(self: DoubleCommandWithCP56Time2a) =
  self.virtualFunctionTable = addr((doubleCommandWithCP56Time2aVFT))
  self.`type` = C_DC_TA_1

proc DoubleCommandWithCP56Time2a_destroy*(self: DoubleCommandWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc DoubleCommandWithCP56Time2a_create*(self: DoubleCommandWithCP56Time2a;
                                        ioa: cint; command: cint;
                                        selectCommand: bool; qu: cint;
                                        timestamp: CP56Time2a): DoubleCommandWithCP56Time2a =
  if self == nil:
    self = cast[DoubleCommandWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sDoubleCommandWithCP56Time2a)))
  if self:
    DoubleCommandWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    var dcq: uint8_t = ((qu and 0x00000000) * 4)
    inc(dcq, (uint8_t)(command and 0x00000000))
    if selectCommand:
      dcq = dcq or 0x00000000
    self.dcq = dcq
    self.timestamp = timestamp[]
  return self

proc DoubleCommandWithCP56Time2a_getQU*(self: DoubleCommandWithCP56Time2a): cint =
  return DoubleCommand_getQU(cast[DoubleCommand](self))

proc DoubleCommandWithCP56Time2a_getState*(self: DoubleCommandWithCP56Time2a): cint =
  return DoubleCommand_getState(cast[DoubleCommand](self))

proc DoubleCommandWithCP56Time2a_isSelect*(self: DoubleCommandWithCP56Time2a): bool =
  return DoubleCommand_isSelect(cast[DoubleCommand](self))

proc DoubleCommandWithCP56Time2a_getFromBuffer*(
    self: DoubleCommandWithCP56Time2a; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint): DoubleCommandWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 1):
    return nil
  if self == nil:
    self = cast[DoubleCommandWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sDoubleCommandWithCP56Time2a)))
  if self != nil:
    DoubleCommandWithCP56Time2a_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  DCQ
    self.dcq = msg[inc(startIndex)]
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

proc DoubleCommandWithCP56Time2a_getTimestamp*(self: DoubleCommandWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

## ******************************************
##  StepCommand : InformationObject
## *****************************************

proc StepCommand_encode*(self: StepCommand; frame: Frame;
                        parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.dcq)
  return true

var stepCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](StepCommand_encode),
    cast[DestroyFunction](StepCommand_destroy)]

proc StepCommand_initialize*(self: StepCommand) =
  self.virtualFunctionTable = addr((stepCommandVFT))
  self.`type` = C_RC_NA_1

proc StepCommand_destroy*(self: StepCommand) =
  GLOBAL_FREEMEM(self)

proc StepCommand_create*(self: StepCommand; ioa: cint; command: StepCommandValue;
                        selectCommand: bool; qu: cint): StepCommand =
  if self == nil:
    self = cast[StepCommand](GLOBAL_MALLOC(sizeof(sStepCommand)))
    if self == nil:
      return nil
    else:
      StepCommand_initialize(self)
  self.objectAddress = ioa
  var dcq: uint8_t = ((qu and 0x00000000) * 4)
  inc(dcq, (uint8_t)(command and 0x00000000))
  if selectCommand:
    dcq = dcq or 0x00000000
  self.dcq = dcq
  return self

proc StepCommand_getQU*(self: StepCommand): cint =
  return (self.dcq and 0x00000000) div 4

proc StepCommand_getState*(self: StepCommand): StepCommandValue =
  return (StepCommandValue)(self.dcq and 0x00000000)

proc StepCommand_isSelect*(self: StepCommand): bool =
  return (self.dcq and 0x00000000) == 0x00000000

proc StepCommand_getFromBuffer*(self: StepCommand;
                               parameters: CS101_AppLayerParameters;
                               msg: ptr uint8_t; msgSize: cint; startIndex: cint): StepCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 1):
    return nil
  if self == nil:
    self = cast[StepCommand](GLOBAL_MALLOC(sizeof(sStepCommand)))
  if self != nil:
    StepCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  SCO
    self.dcq = msg[startIndex]
  return self

## ************************************************
##  StepCommandWithCP56Time2a : InformationObject
## ***********************************************

proc StepCommandWithCP56Time2a_encode*(self: StepCommandWithCP56Time2a;
                                      frame: Frame;
                                      parameters: CS101_AppLayerParameters;
                                      isSequence: bool): bool =
  var size: cint = if isSequence: 8 else: (parameters.sizeOfIOA + 8)
  if Frame_getSpaceLeft(frame) < size:
    return false
  StepCommand_encode(cast[StepCommand](self), frame, parameters, isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var stepCommandWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](StepCommandWithCP56Time2a_encode),
    cast[DestroyFunction](StepCommandWithCP56Time2a_destroy)]

proc StepCommandWithCP56Time2a_initialize*(self: StepCommandWithCP56Time2a) =
  self.virtualFunctionTable = addr((stepCommandWithCP56Time2aVFT))
  self.`type` = C_RC_TA_1

proc StepCommandWithCP56Time2a_destroy*(self: StepCommand) =
  GLOBAL_FREEMEM(self)

proc StepCommandWithCP56Time2a_create*(self: StepCommandWithCP56Time2a; ioa: cint;
                                      command: StepCommandValue;
                                      selectCommand: bool; qu: cint;
                                      timestamp: CP56Time2a): StepCommandWithCP56Time2a =
  if self == nil:
    self = cast[StepCommandWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sStepCommandWithCP56Time2a)))
  if self:
    StepCommandWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    var dcq: uint8_t = ((qu and 0x00000000) * 4)
    inc(dcq, (uint8_t)(command and 0x00000000))
    if selectCommand:
      dcq = dcq or 0x00000000
    self.dcq = dcq
    self.timestamp = timestamp[]
  return self

proc StepCommandWithCP56Time2a_getQU*(self: StepCommandWithCP56Time2a): cint =
  return StepCommand_getQU(cast[StepCommand](self))

proc StepCommandWithCP56Time2a_getState*(self: StepCommandWithCP56Time2a): StepCommandValue =
  return StepCommand_getState(cast[StepCommand](self))

proc StepCommandWithCP56Time2a_isSelect*(self: StepCommandWithCP56Time2a): bool =
  return StepCommand_isSelect(cast[StepCommand](self))

proc StepCommandWithCP56Time2a_getFromBuffer*(self: StepCommandWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint): StepCommandWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 8):
    return nil
  if self == nil:
    self = cast[StepCommandWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sStepCommandWithCP56Time2a)))
  if self != nil:
    StepCommandWithCP56Time2a_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  SCO
    self.dcq = msg[inc(startIndex)]
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

proc StepCommandWithCP56Time2a_getTimestamp*(self: StepCommandWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

## ************************************************
##  SetpointCommandNormalized : InformationObject
## **********************************************

proc SetpointCommandNormalized_encode*(self: SetpointCommandNormalized;
                                      frame: Frame;
                                      parameters: CS101_AppLayerParameters;
                                      isSequence: bool): bool =
  var size: cint = if isSequence: 3 else: (parameters.sizeOfIOA + 3)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_appendBytes(frame, self.encodedValue, 2)
  Frame_setNextByte(frame, self.qos)
  return true

var setpointCommandNormalizedVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SetpointCommandNormalized_encode),
    cast[DestroyFunction](SetpointCommandNormalized_destroy)]

proc SetpointCommandNormalized_initialize*(self: SetpointCommandNormalized) =
  self.virtualFunctionTable = addr((setpointCommandNormalizedVFT))
  self.`type` = C_SE_NA_1

proc SetpointCommandNormalized_destroy*(self: SetpointCommandNormalized) =
  GLOBAL_FREEMEM(self)

proc SetpointCommandNormalized_create*(self: SetpointCommandNormalized; ioa: cint;
                                      value: cfloat; selectCommand: bool; ql: cint): SetpointCommandNormalized =
  if self == nil:
    self = cast[SetpointCommandNormalized](GLOBAL_MALLOC(
        sizeof(sSetpointCommandNormalized)))
  if self:
    SetpointCommandNormalized_initialize(self)
    self.objectAddress = ioa
    var scaledValue: cint = (int)((value * 32767.5) - 0.5)
    setScaledValue(self.encodedValue, scaledValue)
    var qos: uint8_t = ql
    if selectCommand:
      qos = qos or 0x00000000
    self.qos = qos
  return self

proc SetpointCommandNormalized_getValue*(self: SetpointCommandNormalized): cfloat =
  var nv: cfloat = (cast[cfloat](getScaledValue(self.encodedValue)) + 0.5) div
      32767.5
  return nv

proc SetpointCommandNormalized_getQL*(self: SetpointCommandNormalized): cint =
  return (int)(self.qos and 0x00000000)

proc SetpointCommandNormalized_isSelect*(self: SetpointCommandNormalized): bool =
  return (self.qos and 0x00000000) == 0x00000000

proc SetpointCommandNormalized_getFromBuffer*(self: SetpointCommandNormalized;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint): SetpointCommandNormalized =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 3):
    return nil
  if self == nil:
    self = cast[SetpointCommandNormalized](GLOBAL_MALLOC(
        sizeof(sSetpointCommandNormalized)))
  if self != nil:
    SetpointCommandNormalized_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  QOS - qualifier of setpoint command
    self.qos = msg[startIndex]
  return self

## *********************************************************************
##  SetpointCommandNormalizedWithCP56Time2a : SetpointCommandNormalized
## ********************************************************************

proc SetpointCommandNormalizedWithCP56Time2a_encode*(
    self: SetpointCommandNormalizedWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 10 else: (parameters.sizeOfIOA + 10)
  if Frame_getSpaceLeft(frame) < size:
    return false
  SetpointCommandNormalized_encode(cast[SetpointCommandNormalized](self), frame,
                                   parameters, isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var setpointCommandNormalizedWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SetpointCommandNormalizedWithCP56Time2a_encode),
    cast[DestroyFunction](SetpointCommandNormalizedWithCP56Time2a_destroy)]

proc SetpointCommandNormalizedWithCP56Time2a_initialize*(
    self: SetpointCommandNormalizedWithCP56Time2a) =
  self.virtualFunctionTable = addr((setpointCommandNormalizedWithCP56Time2aVFT))
  self.`type` = C_SE_TA_1

proc SetpointCommandNormalizedWithCP56Time2a_destroy*(
    self: SetpointCommandNormalizedWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc SetpointCommandNormalizedWithCP56Time2a_create*(
    self: SetpointCommandNormalizedWithCP56Time2a; ioa: cint; value: cfloat;
    selectCommand: bool; ql: cint; timestamp: CP56Time2a): SetpointCommandNormalizedWithCP56Time2a =
  if self == nil:
    self = cast[SetpointCommandNormalizedWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sSetpointCommandNormalizedWithCP56Time2a)))
  if self:
    SetpointCommandNormalizedWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    var scaledValue: cint = (int)(value * 32767.0)
    setScaledValue(self.encodedValue, scaledValue)
    var qos: uint8_t = ql
    if selectCommand:
      qos = qos or 0x00000000
    self.qos = qos
    self.timestamp = timestamp[]
  return self

proc SetpointCommandNormalizedWithCP56Time2a_getValue*(
    self: SetpointCommandNormalizedWithCP56Time2a): cfloat =
  return SetpointCommandNormalized_getValue(cast[SetpointCommandNormalized](self))

proc SetpointCommandNormalizedWithCP56Time2a_getQL*(
    self: SetpointCommandNormalizedWithCP56Time2a): cint =
  return SetpointCommandNormalized_getQL(cast[SetpointCommandNormalized](self))

proc SetpointCommandNormalizedWithCP56Time2a_isSelect*(
    self: SetpointCommandNormalizedWithCP56Time2a): bool =
  return SetpointCommandNormalized_isSelect(cast[SetpointCommandNormalized](self))

proc SetpointCommandNormalizedWithCP56Time2a_getFromBuffer*(
    self: SetpointCommandNormalizedWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint): SetpointCommandNormalizedWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 10):
    return nil
  if self == nil:
    self = cast[SetpointCommandNormalizedWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sSetpointCommandNormalizedWithCP56Time2a)))
  if self != nil:
    SetpointCommandNormalizedWithCP56Time2a_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  QOS - qualifier of setpoint command
    self.qos = msg[inc(startIndex)]
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

proc SetpointCommandNormalizedWithCP56Time2a_getTimestamp*(
    self: SetpointCommandNormalizedWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

## ************************************************
##  SetpointCommandScaled: InformationObject
## **********************************************

proc SetpointCommandScaled_encode*(self: SetpointCommandScaled; frame: Frame;
                                  parameters: CS101_AppLayerParameters;
                                  isSequence: bool): bool =
  var size: cint = if isSequence: 3 else: (parameters.sizeOfIOA + 3)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_appendBytes(frame, self.encodedValue, 2)
  Frame_setNextByte(frame, self.qos)
  return true

var setpointCommandScaledVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SetpointCommandScaled_encode),
    cast[DestroyFunction](SetpointCommandScaled_destroy)]

proc SetpointCommandScaled_initialize*(self: SetpointCommandScaled) =
  self.virtualFunctionTable = addr((setpointCommandScaledVFT))
  self.`type` = C_SE_NB_1

proc SetpointCommandScaled_destroy*(self: SetpointCommandScaled) =
  GLOBAL_FREEMEM(self)

proc SetpointCommandScaled_create*(self: SetpointCommandScaled; ioa: cint;
                                  value: cint; selectCommand: bool; ql: cint): SetpointCommandScaled =
  if self == nil:
    self = cast[SetpointCommandScaled](GLOBAL_MALLOC(
        sizeof(sSetpointCommandScaled)))
  if self:
    SetpointCommandScaled_initialize(self)
    self.objectAddress = ioa
    setScaledValue(self.encodedValue, value)
    var qos: uint8_t = ql
    if selectCommand:
      qos = qos or 0x00000000
    self.qos = qos
  return self

proc SetpointCommandScaled_getValue*(self: SetpointCommandScaled): cint =
  return getScaledValue(self.encodedValue)

proc SetpointCommandScaled_getQL*(self: SetpointCommandScaled): cint =
  return (int)(self.qos and 0x00000000)

proc SetpointCommandScaled_isSelect*(self: SetpointCommandScaled): bool =
  return (self.qos and 0x00000000) == 0x00000000

proc SetpointCommandScaled_getFromBuffer*(self: SetpointCommandScaled;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint): SetpointCommandScaled =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 3):
    return nil
  if self == nil:
    self = cast[SetpointCommandScaled](GLOBAL_MALLOC(
        sizeof(sSetpointCommandScaled)))
  if self != nil:
    SetpointCommandScaled_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  QOS - qualifier of setpoint command
    self.qos = msg[startIndex]
  return self

## *********************************************************************
##  SetpointCommandScaledWithCP56Time2a : SetpointCommandScaled
## ********************************************************************

proc SetpointCommandScaledWithCP56Time2a_encode*(
    self: SetpointCommandScaledWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 10 else: (parameters.sizeOfIOA + 10)
  if Frame_getSpaceLeft(frame) < size:
    return false
  SetpointCommandScaled_encode(cast[SetpointCommandScaled](self), frame,
                               parameters, isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var setpointCommandScaledWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SetpointCommandScaledWithCP56Time2a_encode),
    cast[DestroyFunction](SetpointCommandScaledWithCP56Time2a_destroy)]

proc SetpointCommandScaledWithCP56Time2a_initialize*(
    self: SetpointCommandScaledWithCP56Time2a) =
  self.virtualFunctionTable = addr((setpointCommandScaledWithCP56Time2aVFT))
  self.`type` = C_SE_TB_1

proc SetpointCommandScaledWithCP56Time2a_destroy*(
    self: SetpointCommandScaledWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc SetpointCommandScaledWithCP56Time2a_create*(
    self: SetpointCommandScaledWithCP56Time2a; ioa: cint; value: cint;
    selectCommand: bool; ql: cint; timestamp: CP56Time2a): SetpointCommandScaledWithCP56Time2a =
  if self == nil:
    self = cast[SetpointCommandScaledWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sSetpointCommandScaledWithCP56Time2a)))
  if self:
    SetpointCommandScaledWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    setScaledValue(self.encodedValue, value)
    var qos: uint8_t = ql
    if selectCommand:
      qos = qos or 0x00000000
    self.qos = qos
    self.timestamp = timestamp[]
  return self

proc SetpointCommandScaledWithCP56Time2a_getValue*(
    self: SetpointCommandScaledWithCP56Time2a): cint =
  return SetpointCommandScaled_getValue(cast[SetpointCommandScaled](self))

proc SetpointCommandScaledWithCP56Time2a_getQL*(
    self: SetpointCommandScaledWithCP56Time2a): cint =
  return SetpointCommandScaled_getQL(cast[SetpointCommandScaled](self))

proc SetpointCommandScaledWithCP56Time2a_isSelect*(
    self: SetpointCommandScaledWithCP56Time2a): bool =
  return SetpointCommandScaled_isSelect(cast[SetpointCommandScaled](self))

proc SetpointCommandScaledWithCP56Time2a_getFromBuffer*(
    self: SetpointCommandScaledWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint): SetpointCommandScaledWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 10):
    return nil
  if self == nil:
    self = cast[SetpointCommandScaledWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sSetpointCommandScaledWithCP56Time2a)))
  if self != nil:
    SetpointCommandScaledWithCP56Time2a_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.encodedValue[0] = msg[inc(startIndex)]
    self.encodedValue[1] = msg[inc(startIndex)]
    ##  QOS - qualifier of setpoint command
    self.qos = msg[inc(startIndex)]
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

proc SetpointCommandScaledWithCP56Time2a_getTimestamp*(
    self: SetpointCommandScaledWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

## ************************************************
##  SetpointCommandShort: InformationObject
## **********************************************

proc SetpointCommandShort_encode*(self: SetpointCommandShort; frame: Frame;
                                 parameters: CS101_AppLayerParameters;
                                 isSequence: bool): bool =
  var size: cint = if isSequence: 5 else: (parameters.sizeOfIOA + 5)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
  when (ORDER_LITTLE_ENDIAN == 1):
    Frame_appendBytes(frame, valueBytes, 4)
  else:
    Frame_setNextByte(frame, valueBytes[3])
    Frame_setNextByte(frame, valueBytes[2])
    Frame_setNextByte(frame, valueBytes[1])
    Frame_setNextByte(frame, valueBytes[0])
  Frame_setNextByte(frame, self.qos)
  return true

var setpointCommandShortVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SetpointCommandShort_encode),
    cast[DestroyFunction](SetpointCommandShort_destroy)]

proc SetpointCommandShort_initialize*(self: SetpointCommandShort) =
  self.virtualFunctionTable = addr((setpointCommandShortVFT))
  self.`type` = C_SE_NC_1

proc SetpointCommandShort_destroy*(self: SetpointCommandShort) =
  GLOBAL_FREEMEM(self)

proc SetpointCommandShort_create*(self: SetpointCommandShort; ioa: cint;
                                 value: cfloat; selectCommand: bool; ql: cint): SetpointCommandShort =
  if self == nil:
    self = cast[SetpointCommandShort](GLOBAL_MALLOC(sizeof(sSetpointCommandShort)))
  if self:
    SetpointCommandShort_initialize(self)
    self.objectAddress = ioa
    self.value = value
    var qos: uint8_t = ql and 0x00000000
    if selectCommand:
      qos = qos or 0x00000000
    self.qos = qos
  return self

proc SetpointCommandShort_getValue*(self: SetpointCommandShort): cfloat =
  return self.value

proc SetpointCommandShort_getQL*(self: SetpointCommandShort): cint =
  return (int)(self.qos and 0x00000000)

proc SetpointCommandShort_isSelect*(self: SetpointCommandShort): bool =
  return (self.qos and 0x00000000) == 0x00000000

proc SetpointCommandShort_getFromBuffer*(self: SetpointCommandShort;
                                        parameters: CS101_AppLayerParameters;
                                        msg: ptr uint8_t; msgSize: cint;
                                        startIndex: cint): SetpointCommandShort =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 5):
    return nil
  if self == nil:
    self = cast[SetpointCommandShort](GLOBAL_MALLOC(sizeof(sSetpointCommandShort)))
  if self != nil:
    SetpointCommandShort_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
    when (ORDER_LITTLE_ENDIAN == 1):
      valueBytes[0] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[3] = msg[inc(startIndex)]
    else:
      valueBytes[3] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[0] = msg[inc(startIndex)]
    ##  QOS - qualifier of setpoint command
    self.qos = msg[startIndex]
  return self

## *********************************************************************
##  SetpointCommandShortWithCP56Time2a : SetpointCommandShort
## ********************************************************************

proc SetpointCommandShortWithCP56Time2a_encode*(
    self: SetpointCommandShortWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 12 else: (parameters.sizeOfIOA + 12)
  if Frame_getSpaceLeft(frame) < size:
    return false
  SetpointCommandShort_encode(cast[SetpointCommandShort](self), frame, parameters,
                              isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var setpointCommandShortWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SetpointCommandShortWithCP56Time2a_encode),
    cast[DestroyFunction](SetpointCommandShortWithCP56Time2a_destroy)]

proc SetpointCommandShortWithCP56Time2a_initialize*(
    self: SetpointCommandShortWithCP56Time2a) =
  self.virtualFunctionTable = addr((setpointCommandShortWithCP56Time2aVFT))
  self.`type` = C_SE_TC_1

proc SetpointCommandShortWithCP56Time2a_destroy*(
    self: SetpointCommandShortWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc SetpointCommandShortWithCP56Time2a_create*(
    self: SetpointCommandShortWithCP56Time2a; ioa: cint; value: cfloat;
    selectCommand: bool; ql: cint; timestamp: CP56Time2a): SetpointCommandShortWithCP56Time2a =
  if self == nil:
    self = cast[SetpointCommandShortWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sSetpointCommandShortWithCP56Time2a)))
  if self:
    SetpointCommandShortWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    var qos: uint8_t = ql
    if selectCommand:
      qos = qos or 0x00000000
    self.qos = qos
    self.timestamp = timestamp[]
  return self

proc SetpointCommandShortWithCP56Time2a_getValue*(
    self: SetpointCommandShortWithCP56Time2a): cfloat =
  return SetpointCommandShort_getValue(cast[SetpointCommandShort](self))

proc SetpointCommandShortWithCP56Time2a_getQL*(
    self: SetpointCommandShortWithCP56Time2a): cint =
  return SetpointCommandShort_getQL(cast[SetpointCommandShort](self))

proc SetpointCommandShortWithCP56Time2a_isSelect*(
    self: SetpointCommandShortWithCP56Time2a): bool =
  return SetpointCommandShort_isSelect(cast[SetpointCommandShort](self))

proc SetpointCommandShortWithCP56Time2a_getFromBuffer*(
    self: SetpointCommandShortWithCP56Time2a;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint): SetpointCommandShortWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 10):
    return nil
  if self == nil:
    self = cast[SetpointCommandShortWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sSetpointCommandShortWithCP56Time2a)))
  if self != nil:
    SetpointCommandShortWithCP56Time2a_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
    when (ORDER_LITTLE_ENDIAN == 1):
      valueBytes[0] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[3] = msg[inc(startIndex)]
    else:
      valueBytes[3] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[0] = msg[inc(startIndex)]
    ##  QOS - qualifier of setpoint command
    self.qos = msg[inc(startIndex)]
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

proc SetpointCommandShortWithCP56Time2a_getTimestamp*(
    self: SetpointCommandShortWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

## ************************************************
##  Bitstring32Command : InformationObject
## **********************************************

proc Bitstring32Command_encode*(self: Bitstring32Command; frame: Frame;
                               parameters: CS101_AppLayerParameters;
                               isSequence: bool): bool =
  var size: cint = if isSequence: 5 else: (parameters.sizeOfIOA + 5)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
  when (ORDER_LITTLE_ENDIAN == 1):
    Frame_appendBytes(frame, valueBytes, 4)
  else:
    Frame_setNextByte(frame, valueBytes[3])
    Frame_setNextByte(frame, valueBytes[2])
    Frame_setNextByte(frame, valueBytes[1])
    Frame_setNextByte(frame, valueBytes[0])
  return true

var bitstring32CommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](Bitstring32Command_encode),
    cast[DestroyFunction](Bitstring32Command_destroy)]

proc Bitstring32Command_initialize*(self: Bitstring32Command) =
  self.virtualFunctionTable = addr((bitstring32CommandVFT))
  self.`type` = C_BO_NA_1

proc Bitstring32Command_create*(self: Bitstring32Command; ioa: cint; value: uint32_t): Bitstring32Command =
  if self == nil:
    self = cast[Bitstring32Command](GLOBAL_MALLOC(sizeof(sBitstring32Command)))
  if self:
    Bitstring32Command_initialize(self)
    self.objectAddress = ioa
    self.value = value
  return self

proc Bitstring32Command_destroy*(self: Bitstring32Command) =
  GLOBAL_FREEMEM(self)

proc Bitstring32Command_getValue*(self: Bitstring32Command): uint32_t =
  return self.value

proc Bitstring32Command_getFromBuffer*(self: Bitstring32Command;
                                      parameters: CS101_AppLayerParameters;
                                      msg: ptr uint8_t; msgSize: cint;
                                      startIndex: cint): Bitstring32Command =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 4):
    return nil
  if self == nil:
    self = cast[Bitstring32Command](GLOBAL_MALLOC(sizeof(sBitstring32Command)))
  if self != nil:
    Bitstring32Command_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
    when (ORDER_LITTLE_ENDIAN == 1):
      valueBytes[0] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[3] = msg[inc(startIndex)]
    else:
      valueBytes[3] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[0] = msg[inc(startIndex)]
  return self

## ******************************************************
##  Bitstring32CommandWithCP56Time2a: Bitstring32Command
## *****************************************************

proc Bitstring32CommandWithCP56Time2a_encode*(
    self: Bitstring32CommandWithCP56Time2a; frame: Frame;
    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 12 else: (parameters.sizeOfIOA + 12)
  if Frame_getSpaceLeft(frame) < size:
    return false
  Bitstring32Command_encode(cast[Bitstring32Command](self), frame, parameters,
                            isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var bitstring32CommandWithCP56Time2aVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](Bitstring32CommandWithCP56Time2a_encode),
    cast[DestroyFunction](Bitstring32CommandWithCP56Time2a_destroy)]

proc Bitstring32CommandWithCP56Time2a_initialize*(
    self: Bitstring32CommandWithCP56Time2a) =
  self.virtualFunctionTable = addr((bitstring32CommandWithCP56Time2aVFT))
  self.`type` = C_BO_TA_1

proc Bitstring32CommandWithCP56Time2a_create*(
    self: Bitstring32CommandWithCP56Time2a; ioa: cint; value: uint32_t;
    timestamp: CP56Time2a): Bitstring32CommandWithCP56Time2a =
  if self == nil:
    self = cast[Bitstring32CommandWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sBitstring32CommandWithCP56Time2a)))
  if self:
    Bitstring32CommandWithCP56Time2a_initialize(self)
    self.objectAddress = ioa
    self.value = value
    self.timestamp = timestamp[]
  return self

proc Bitstring32CommandWithCP56Time2a_destroy*(
    self: Bitstring32CommandWithCP56Time2a) =
  GLOBAL_FREEMEM(self)

proc Bitstring32CommandWithCP56Time2a_getValue*(
    self: Bitstring32CommandWithCP56Time2a): uint32_t =
  return self.value

proc Bitstring32CommandWithCP56Time2a_getTimestamp*(
    self: Bitstring32CommandWithCP56Time2a): CP56Time2a =
  return addr((self.timestamp))

proc Bitstring32CommandWithCP56Time2a_getFromBuffer*(
    self: Bitstring32CommandWithCP56Time2a; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint): Bitstring32CommandWithCP56Time2a =
  if (msgSize - startIndex) < (parameters.sizeOfIOA + 11):
    return nil
  if self == nil:
    self = cast[Bitstring32CommandWithCP56Time2a](GLOBAL_MALLOC(
        sizeof(sBitstring32CommandWithCP56Time2a)))
  if self != nil:
    Bitstring32CommandWithCP56Time2a_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    var valueBytes: ptr uint8_t = cast[ptr uint8_t](addr((self.value)))
    when (ORDER_LITTLE_ENDIAN == 1):
      valueBytes[0] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[3] = msg[inc(startIndex)]
    else:
      valueBytes[3] = msg[inc(startIndex)]
      valueBytes[2] = msg[inc(startIndex)]
      valueBytes[1] = msg[inc(startIndex)]
      valueBytes[0] = msg[inc(startIndex)]
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ************************************************
##  ReadCommand : InformationObject
## **********************************************

proc ReadCommand_encode*(self: ReadCommand; frame: Frame;
                        parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 0 else: (parameters.sizeOfIOA + 0)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  return true

var readCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](ReadCommand_encode),
    cast[DestroyFunction](ReadCommand_destroy)]

proc ReadCommand_initialize*(self: ReadCommand) =
  self.virtualFunctionTable = addr((readCommandVFT))
  self.`type` = C_RD_NA_1

proc ReadCommand_create*(self: ReadCommand; ioa: cint): ReadCommand =
  if self == nil:
    self = cast[ReadCommand](GLOBAL_MALLOC(sizeof(sReadCommand)))
  if self:
    ReadCommand_initialize(self)
    self.objectAddress = ioa
  return self

proc ReadCommand_destroy*(self: ReadCommand) =
  GLOBAL_FREEMEM(self)

proc ReadCommand_getFromBuffer*(self: ReadCommand;
                               parameters: CS101_AppLayerParameters;
                               msg: ptr uint8_t; msgSize: cint; startIndex: cint): ReadCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA):
    return nil
  if self == nil:
    self = cast[ReadCommand](GLOBAL_MALLOC(sizeof(sReadCommand)))
  if self != nil:
    ReadCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
  return self

## **************************************************
##  ClockSynchronizationCommand : InformationObject
## ************************************************

proc ClockSynchronizationCommand_encode*(self: ClockSynchronizationCommand;
                                        frame: Frame;
                                        parameters: CS101_AppLayerParameters;
                                        isSequence: bool): bool =
  var size: cint = if isSequence: 7 else: (parameters.sizeOfIOA + 7)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_appendBytes(frame, self.timestamp.encodedValue, 7)
  return true

var clockSynchronizationCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](ClockSynchronizationCommand_encode),
    cast[DestroyFunction](ClockSynchronizationCommand_destroy)]

proc ClockSynchronizationCommand_initialize*(self: ClockSynchronizationCommand) =
  self.virtualFunctionTable = addr((clockSynchronizationCommandVFT))
  self.`type` = C_CS_NA_1

proc ClockSynchronizationCommand_create*(self: ClockSynchronizationCommand;
                                        ioa: cint; timestamp: CP56Time2a): ClockSynchronizationCommand =
  if self == nil:
    self = cast[ClockSynchronizationCommand](GLOBAL_MALLOC(
        sizeof(sClockSynchronizationCommand)))
  if self:
    ClockSynchronizationCommand_initialize(self)
    self.objectAddress = ioa
    self.timestamp = timestamp[]
  return self

proc ClockSynchronizationCommand_destroy*(self: ClockSynchronizationCommand) =
  GLOBAL_FREEMEM(self)

proc ClockSynchronizationCommand_getTime*(self: ClockSynchronizationCommand): CP56Time2a =
  return addr((self.timestamp))

proc ClockSynchronizationCommand_getFromBuffer*(
    self: ClockSynchronizationCommand; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint): ClockSynchronizationCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 7:
    return nil
  if self == nil:
    self = cast[ClockSynchronizationCommand](GLOBAL_MALLOC(
        sizeof(sClockSynchronizationCommand)))
  if self != nil:
    ClockSynchronizationCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  timestamp
    CP56Time2a_getFromBuffer(addr((self.timestamp)), msg, msgSize, startIndex)
  return self

## ************************************************
##  InterrogationCommand : InformationObject
## **********************************************

proc InterrogationCommand_encode*(self: InterrogationCommand; frame: Frame;
                                 parameters: CS101_AppLayerParameters;
                                 isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.qoi)
  return true

var interrogationCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](InterrogationCommand_encode),
    cast[DestroyFunction](InterrogationCommand_destroy)]

proc InterrogationCommand_initialize*(self: InterrogationCommand) =
  self.virtualFunctionTable = addr((interrogationCommandVFT))
  self.`type` = C_IC_NA_1

proc InterrogationCommand_create*(self: InterrogationCommand; ioa: cint; qoi: uint8_t): InterrogationCommand =
  if self == nil:
    self = cast[InterrogationCommand](GLOBAL_MALLOC(sizeof(sInterrogationCommand)))
  if self:
    InterrogationCommand_initialize(self)
    self.objectAddress = ioa
    self.qoi = qoi
  return self

proc InterrogationCommand_destroy*(self: InterrogationCommand) =
  GLOBAL_FREEMEM(self)

proc InterrogationCommand_getQOI*(self: InterrogationCommand): uint8_t =
  return self.qoi

proc InterrogationCommand_getFromBuffer*(self: InterrogationCommand;
                                        parameters: CS101_AppLayerParameters;
                                        msg: ptr uint8_t; msgSize: cint;
                                        startIndex: cint): InterrogationCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 1:
    return nil
  if self == nil:
    self = cast[InterrogationCommand](GLOBAL_MALLOC(sizeof(sInterrogationCommand)))
  if self != nil:
    InterrogationCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  QUI
    self.qoi = msg[startIndex]
  return self

## *************************************************
##  CounterInterrogationCommand : InformationObject
## ************************************************

proc CounterInterrogationCommand_encode*(self: CounterInterrogationCommand;
                                        frame: Frame;
                                        parameters: CS101_AppLayerParameters;
                                        isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.qcc)
  return true

var counterInterrogationCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](CounterInterrogationCommand_encode),
    cast[DestroyFunction](CounterInterrogationCommand_destroy)]

proc CounterInterrogationCommand_initialize*(self: CounterInterrogationCommand) =
  self.virtualFunctionTable = addr((counterInterrogationCommandVFT))
  self.`type` = C_CI_NA_1

proc CounterInterrogationCommand_create*(self: CounterInterrogationCommand;
                                        ioa: cint; qcc: QualifierOfCIC): CounterInterrogationCommand =
  if self == nil:
    self = cast[CounterInterrogationCommand](GLOBAL_MALLOC(
        sizeof(sCounterInterrogationCommand)))
  if self:
    CounterInterrogationCommand_initialize(self)
    self.objectAddress = ioa
    self.qcc = qcc
  return self

proc CounterInterrogationCommand_destroy*(self: CounterInterrogationCommand) =
  GLOBAL_FREEMEM(self)

proc CounterInterrogationCommand_getQCC*(self: CounterInterrogationCommand): QualifierOfCIC =
  return self.qcc

proc CounterInterrogationCommand_getFromBuffer*(
    self: CounterInterrogationCommand; parameters: CS101_AppLayerParameters;
    msg: ptr uint8_t; msgSize: cint; startIndex: cint): CounterInterrogationCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 1:
    return nil
  if self == nil:
    self = cast[CounterInterrogationCommand](GLOBAL_MALLOC(
        sizeof(sCounterInterrogationCommand)))
  if self != nil:
    CounterInterrogationCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  QCC
    self.qcc = msg[startIndex]
  return self

## ************************************************
##  TestCommand : InformationObject
## **********************************************

proc TestCommand_encode*(self: TestCommand; frame: Frame;
                        parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 2 else: (parameters.sizeOfIOA + 2)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.byte1)
  Frame_setNextByte(frame, self.byte2)
  return true

var testCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](TestCommand_encode),
    cast[DestroyFunction](TestCommand_destroy)]

proc TestCommand_initialize*(self: TestCommand) =
  self.virtualFunctionTable = addr((testCommandVFT))
  self.`type` = C_TS_NA_1

proc TestCommand_create*(self: TestCommand): TestCommand =
  if self == nil:
    self = cast[TestCommand](GLOBAL_MALLOC(sizeof(sTestCommand)))
  if self:
    TestCommand_initialize(self)
    self.objectAddress = 0
    self.byte1 = 0x00000000
    self.byte2 = 0x00000000
  return self

proc TestCommand_destroy*(self: TestCommand) =
  GLOBAL_FREEMEM(self)

proc TestCommand_isValid*(self: TestCommand): bool =
  if (self.byte1 == 0x00000000) and (self.byte2 == 0x00000000):
    return true
  else:
    return false

proc TestCommand_getFromBuffer*(self: TestCommand;
                               parameters: CS101_AppLayerParameters;
                               msg: ptr uint8_t; msgSize: cint; startIndex: cint): TestCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 1:
    return nil
  if self == nil:
    self = cast[TestCommand](GLOBAL_MALLOC(sizeof(sTestCommand)))
  if self != nil:
    TestCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  test bytes
    self.byte1 = msg[inc(startIndex)]
    self.byte2 = msg[startIndex]
  return self

## ************************************************
##  ResetProcessCommand : InformationObject
## **********************************************

proc ResetProcessCommand_encode*(self: ResetProcessCommand; frame: Frame;
                                parameters: CS101_AppLayerParameters;
                                isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.qrp)
  return true

var resetProcessCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](ResetProcessCommand_encode),
    cast[DestroyFunction](ResetProcessCommand_destroy)]

proc ResetProcessCommand_initialize*(self: ResetProcessCommand) =
  self.virtualFunctionTable = addr((resetProcessCommandVFT))
  self.`type` = C_RP_NA_1

proc ResetProcessCommand_create*(self: ResetProcessCommand; ioa: cint;
                                qrp: QualifierOfRPC): ResetProcessCommand =
  if self == nil:
    self = cast[ResetProcessCommand](GLOBAL_MALLOC(sizeof(sResetProcessCommand)))
  if self:
    ResetProcessCommand_initialize(self)
    self.objectAddress = ioa
    self.qrp = qrp
  return self

proc ResetProcessCommand_destroy*(self: ResetProcessCommand) =
  GLOBAL_FREEMEM(self)

proc ResetProcessCommand_getQRP*(self: ResetProcessCommand): QualifierOfRPC =
  return self.qrp

proc ResetProcessCommand_getFromBuffer*(self: ResetProcessCommand;
                                       parameters: CS101_AppLayerParameters;
                                       msg: ptr uint8_t; msgSize: cint;
                                       startIndex: cint): ResetProcessCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 1:
    return nil
  if self == nil:
    self = cast[ResetProcessCommand](GLOBAL_MALLOC(sizeof(sResetProcessCommand)))
  if self != nil:
    ResetProcessCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  QUI
    self.qrp = msg[startIndex]
  return self

## ************************************************
##  DelayAcquisitionCommand : InformationObject
## **********************************************

proc DelayAcquisitionCommand_encode*(self: DelayAcquisitionCommand; frame: Frame;
                                    parameters: CS101_AppLayerParameters;
                                    isSequence: bool): bool =
  var size: cint = if isSequence: 2 else: (parameters.sizeOfIOA + 2)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_appendBytes(frame, self.delay.encodedValue, 2)
  return true

var DelayAcquisitionCommandVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](DelayAcquisitionCommand_encode),
    cast[DestroyFunction](DelayAcquisitionCommand_destroy)]

proc DelayAcquisitionCommand_initialize*(self: DelayAcquisitionCommand) =
  self.virtualFunctionTable = addr((DelayAcquisitionCommandVFT))
  self.`type` = C_CD_NA_1

proc DelayAcquisitionCommand_create*(self: DelayAcquisitionCommand; ioa: cint;
                                    delay: CP16Time2a): DelayAcquisitionCommand =
  if self == nil:
    self = cast[DelayAcquisitionCommand](GLOBAL_MALLOC(
        sizeof(sDelayAcquisitionCommand)))
  if self:
    DelayAcquisitionCommand_initialize(self)
    self.objectAddress = ioa
    self.delay = delay[]
  return self

proc DelayAcquisitionCommand_destroy*(self: DelayAcquisitionCommand) =
  GLOBAL_FREEMEM(self)

proc DelayAcquisitionCommand_getDelay*(self: DelayAcquisitionCommand): CP16Time2a =
  return addr((self.delay))

proc DelayAcquisitionCommand_getFromBuffer*(self: DelayAcquisitionCommand;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint): DelayAcquisitionCommand =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 1:
    return nil
  if self == nil:
    self = cast[DelayAcquisitionCommand](GLOBAL_MALLOC(
        sizeof(sDelayAcquisitionCommand)))
  if self != nil:
    DelayAcquisitionCommand_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  delay
    CP16Time2a_getFromBuffer(addr((self.delay)), msg, msgSize, startIndex)
  return self

## ******************************************
##  ParameterActivation : InformationObject
## *****************************************

proc ParameterActivation_encode*(self: ParameterActivation; frame: Frame;
                                parameters: CS101_AppLayerParameters;
                                isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.qpa)
  return true

var parameterActivationVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](ParameterActivation_encode),
    cast[DestroyFunction](ParameterActivation_destroy)]

proc ParameterActivation_initialize*(self: ParameterActivation) =
  self.virtualFunctionTable = addr((parameterActivationVFT))
  self.`type` = P_AC_NA_1

proc ParameterActivation_destroy*(self: ParameterActivation) =
  GLOBAL_FREEMEM(self)

proc ParameterActivation_create*(self: ParameterActivation; ioa: cint;
                                qpa: QualifierOfParameterActivation): ParameterActivation =
  if self == nil:
    self = cast[ParameterActivation](GLOBAL_CALLOC(1, sizeof(sParameterActivation)))
  if self:
    ParameterActivation_initialize(self)
    self.objectAddress = ioa
    self.qpa = qpa
  return self

proc ParameterActivation_getQuality*(self: ParameterActivation): QualifierOfParameterActivation =
  return self.qpa

proc ParameterActivation_getFromBuffer*(self: ParameterActivation;
                                       parameters: CS101_AppLayerParameters;
                                       msg: ptr uint8_t; msgSize: cint;
                                       startIndex: cint): ParameterActivation =
  if self == nil:
    self = cast[ParameterActivation](GLOBAL_MALLOC(sizeof(sParameterActivation)))
  if self:
    ParameterActivation_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  QPA
    self.qpa = cast[QualifierOfParameterActivation](msg[inc(startIndex)])
  return self

## ******************************************
##  EndOfInitialization : InformationObject
## *****************************************

proc EndOfInitialization_encode*(self: EndOfInitialization; frame: Frame;
                                parameters: CS101_AppLayerParameters;
                                isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, self.coi)
  return true

var EndOfInitializationVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](EndOfInitialization_encode),
    cast[DestroyFunction](EndOfInitialization_destroy)]

proc EndOfInitialization_initialize*(self: EndOfInitialization) =
  self.virtualFunctionTable = addr((EndOfInitializationVFT))
  self.`type` = M_EI_NA_1

proc EndOfInitialization_create*(self: EndOfInitialization; coi: uint8_t): EndOfInitialization =
  if self == nil:
    self = cast[EndOfInitialization](GLOBAL_MALLOC(sizeof(sEndOfInitialization)))
  if self:
    EndOfInitialization_initialize(self)
    self.objectAddress = 0
    self.coi = coi
  return self

nil
proc EndOfInitialization_destroy*(self: EndOfInitialization) =
  GLOBAL_FREEMEM(self)

proc EndOfInitialization_getCOI*(self: EndOfInitialization): uint8_t =
  return self.coi

proc EndOfInitialization_getFromBuffer*(self: EndOfInitialization;
                                       parameters: CS101_AppLayerParameters;
                                       msg: ptr uint8_t; msgSize: cint;
                                       startIndex: cint): EndOfInitialization =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 1:
    return nil
  if self == nil:
    self = cast[EndOfInitialization](GLOBAL_MALLOC(sizeof(sEndOfInitialization)))
  if self:
    EndOfInitialization_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    ##  COI
    self.coi = msg[startIndex]
  return self

## ******************************************
##  FileReady : InformationObject
## *****************************************

proc FileReady_encode*(self: FileReady; frame: Frame;
                      parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof mod 256)))
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof div 256)))
  Frame_setNextByte(frame, (uint8_t)(self.lengthOfFile mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)((self.lengthOfFile div 0x00000000) mod
      0x00000000))
  Frame_setNextByte(frame, (uint8_t)((self.lengthOfFile div 0x00000000) mod
      0x00000000))
  Frame_setNextByte(frame, self.frq)
  return true

var FileReadyVFT*: sInformationObjectVFT = [cast[EncodeFunction](FileReady_encode), cast[DestroyFunction](FileReady_destroy)]

proc FileReady_initialize*(self: FileReady) =
  self.virtualFunctionTable = addr((FileReadyVFT))
  self.`type` = F_FR_NA_1

proc FileReady_create*(self: FileReady; ioa: cint; nof: uint16_t;
                      lengthOfFile: uint32_t; positive: bool): FileReady =
  if self == nil:
    self = cast[FileReady](GLOBAL_MALLOC(sizeof(sFileReady)))
  if self:
    FileReady_initialize(self)
    self.objectAddress = ioa
    self.nof = nof
    self.lengthOfFile = lengthOfFile
    if positive:
      self.frq = 0x00000000
    else:
      self.frq = 0
  return self

proc FileReady_getFRQ*(self: FileReady): uint8_t =
  return self.frq

proc FileReady_setFRQ*(self: FileReady; frq: uint8_t) =
  self.frq = frq

proc FileReady_isPositive*(self: FileReady): bool =
  return (self.frq and 0x00000000) == 0x00000000

proc FileReady_getNOF*(self: FileReady): uint16_t =
  return self.nof

proc FileReady_getLengthOfFile*(self: FileReady): uint32_t =
  return self.lengthOfFile

proc FileReady_destroy*(self: FileReady) =
  GLOBAL_FREEMEM(self)

proc FileReady_getFromBuffer*(self: FileReady;
                             parameters: CS101_AppLayerParameters;
                             msg: ptr uint8_t; msgSize: cint; startIndex: cint): FileReady =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 6:
    return nil
  if self == nil:
    self = cast[FileReady](GLOBAL_MALLOC(sizeof(sFileReady)))
  if self != nil:
    FileReady_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.nof = msg[inc(startIndex)]
    inc(self.nof, (msg[inc(startIndex)] * 0x00000000))
    self.lengthOfFile = msg[inc(startIndex)]
    inc(self.lengthOfFile, (msg[inc(startIndex)] * 0x00000000))
    inc(self.lengthOfFile, (msg[inc(startIndex)] * 0x00000000))
    ##  FRQ
    self.frq = msg[startIndex]
  return self

## ******************************************
##  SectionReady : InformationObject
## *****************************************

proc SectionReady_encode*(self: SectionReady; frame: Frame;
                         parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof mod 256)))
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof div 256)))
  Frame_setNextByte(frame, self.nameOfSection)
  Frame_setNextByte(frame, (uint8_t)(self.lengthOfSection mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)((self.lengthOfSection div 0x00000000) mod
      0x00000000))
  Frame_setNextByte(frame, (uint8_t)((self.lengthOfSection div 0x00000000) mod
      0x00000000))
  Frame_setNextByte(frame, self.srq)
  return true

var SectionReadyVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](SectionReady_encode),
    cast[DestroyFunction](SectionReady_destroy)]

proc SectionReady_initialize*(self: SectionReady) =
  self.virtualFunctionTable = addr((SectionReadyVFT))
  self.`type` = F_SR_NA_1

proc SectionReady_create*(self: SectionReady; ioa: cint; nof: uint16_t; nos: uint8_t;
                         lengthOfSection: uint32_t; notReady: bool): SectionReady =
  if self == nil:
    self = cast[SectionReady](GLOBAL_MALLOC(sizeof(sSectionReady)))
  if self != nil:
    SectionReady_initialize(self)
    self.objectAddress = ioa
    self.nof = nof
    self.nameOfSection = nos
    self.lengthOfSection = lengthOfSection
    if notReady:
      self.srq = 0x00000000
    else:
      self.srq = 0
  return self

proc SectionReady_isNotReady*(self: SectionReady): bool =
  return (self.srq and 0x00000000) == 0x00000000

proc SectionReady_getSRQ*(self: SectionReady): uint8_t =
  return self.srq

proc SectionReady_setSRQ*(self: SectionReady; srq: uint8_t) =
  self.srq = srq

proc SectionReady_getNOF*(self: SectionReady): uint16_t =
  return self.nof

proc SectionReady_getNameOfSection*(self: SectionReady): uint8_t =
  return self.nameOfSection

proc SectionReady_getLengthOfSection*(self: SectionReady): uint32_t =
  return self.lengthOfSection

proc SectionReady_destroy*(self: SectionReady) =
  GLOBAL_FREEMEM(self)

proc SectionReady_getFromBuffer*(self: SectionReady;
                                parameters: CS101_AppLayerParameters;
                                msg: ptr uint8_t; msgSize: cint; startIndex: cint): SectionReady =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 7:
    return nil
  if self == nil:
    self = cast[SectionReady](GLOBAL_MALLOC(sizeof(sSectionReady)))
  if self != nil:
    SectionReady_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.nof = msg[inc(startIndex)]
    inc(self.nof, (msg[inc(startIndex)] * 0x00000000))
    self.nameOfSection = msg[inc(startIndex)]
    self.lengthOfSection = msg[inc(startIndex)]
    inc(self.lengthOfSection, (msg[inc(startIndex)] * 0x00000000))
    inc(self.lengthOfSection, (msg[inc(startIndex)] * 0x00000000))
    self.srq = msg[startIndex]
  return self

## ******************************************
##  FileCallOrSelect : InformationObject
## *****************************************

proc FileCallOrSelect_encode*(self: FileCallOrSelect; frame: Frame;
                             parameters: CS101_AppLayerParameters;
                             isSequence: bool): bool =
  var size: cint = if isSequence: 1 else: (parameters.sizeOfIOA + 1)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof mod 256)))
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof div 256)))
  Frame_setNextByte(frame, self.nameOfSection)
  Frame_setNextByte(frame, self.scq)
  return true

var FileCallOrSelectVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](FileCallOrSelect_encode),
    cast[DestroyFunction](FileCallOrSelect_destroy)]

proc FileCallOrSelect_initialize*(self: FileCallOrSelect) =
  self.virtualFunctionTable = addr((FileCallOrSelectVFT))
  self.`type` = F_SC_NA_1

proc FileCallOrSelect_create*(self: FileCallOrSelect; ioa: cint; nof: uint16_t;
                             nos: uint8_t; scq: uint8_t): FileCallOrSelect =
  if self == nil:
    self = cast[FileCallOrSelect](GLOBAL_MALLOC(sizeof(sFileCallOrSelect)))
  if self != nil:
    FileCallOrSelect_initialize(self)
    self.objectAddress = ioa
    self.nof = nof
    self.nameOfSection = nos
    self.scq = scq
  return self

proc FileCallOrSelect_getNOF*(self: FileCallOrSelect): uint16_t =
  return self.nof

proc FileCallOrSelect_getNameOfSection*(self: FileCallOrSelect): uint8_t =
  return self.nameOfSection

proc FileCallOrSelect_getSCQ*(self: FileCallOrSelect): uint8_t =
  return self.scq

proc FileCallOrSelect_destroy*(self: FileCallOrSelect) =
  GLOBAL_FREEMEM(self)

proc FileCallOrSelect_getFromBuffer*(self: FileCallOrSelect;
                                    parameters: CS101_AppLayerParameters;
                                    msg: ptr uint8_t; msgSize: cint; startIndex: cint): FileCallOrSelect =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 4:
    return nil
  if self == nil:
    self = cast[FileCallOrSelect](GLOBAL_MALLOC(sizeof(sFileCallOrSelect)))
  if self != nil:
    FileCallOrSelect_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.nof = msg[inc(startIndex)]
    inc(self.nof, (msg[inc(startIndex)] * 0x00000000))
    self.nameOfSection = msg[inc(startIndex)]
    self.scq = msg[startIndex]
  return self

## ************************************************
##  FileLastSegmentOrSection : InformationObject
## ***********************************************

proc FileLastSegmentOrSection_encode*(self: FileLastSegmentOrSection; frame: Frame;
                                     parameters: CS101_AppLayerParameters;
                                     isSequence: bool): bool =
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof mod 256)))
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof div 256)))
  Frame_setNextByte(frame, self.nameOfSection)
  Frame_setNextByte(frame, self.lsq)
  Frame_setNextByte(frame, self.chs)
  return true

var FileLastSegmentOrSectionVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](FileLastSegmentOrSection_encode),
    cast[DestroyFunction](FileLastSegmentOrSection_destroy)]

proc FileLastSegmentOrSection_initialize*(self: FileLastSegmentOrSection) =
  self.virtualFunctionTable = addr((FileLastSegmentOrSectionVFT))
  self.`type` = F_LS_NA_1

proc FileLastSegmentOrSection_create*(self: FileLastSegmentOrSection; ioa: cint;
                                     nof: uint16_t; nos: uint8_t; lsq: uint8_t;
                                     chs: uint8_t): FileLastSegmentOrSection =
  if self == nil:
    self = cast[FileLastSegmentOrSection](GLOBAL_MALLOC(
        sizeof(sFileLastSegmentOrSection)))
  if self != nil:
    FileLastSegmentOrSection_initialize(self)
    self.objectAddress = ioa
    self.nof = nof
    self.nameOfSection = nos
    self.lsq = lsq
    self.chs = chs
  return self

proc FileLastSegmentOrSection_getNOF*(self: FileLastSegmentOrSection): uint16_t =
  return self.nof

proc FileLastSegmentOrSection_getNameOfSection*(self: FileLastSegmentOrSection): uint8_t =
  return self.nameOfSection

proc FileLastSegmentOrSection_getLSQ*(self: FileLastSegmentOrSection): uint8_t =
  return self.lsq

proc FileLastSegmentOrSection_getCHS*(self: FileLastSegmentOrSection): uint8_t =
  return self.chs

proc FileLastSegmentOrSection_destroy*(self: FileLastSegmentOrSection) =
  GLOBAL_FREEMEM(self)

proc FileLastSegmentOrSection_getFromBuffer*(self: FileLastSegmentOrSection;
    parameters: CS101_AppLayerParameters; msg: ptr uint8_t; msgSize: cint;
    startIndex: cint): FileLastSegmentOrSection =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 5:
    return nil
  if self == nil:
    self = cast[FileLastSegmentOrSection](GLOBAL_MALLOC(
        sizeof(sFileLastSegmentOrSection)))
  if self != nil:
    FileLastSegmentOrSection_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.nof = msg[inc(startIndex)]
    inc(self.nof, (msg[inc(startIndex)] * 0x00000000))
    self.nameOfSection = msg[inc(startIndex)]
    self.lsq = msg[startIndex]
    self.chs = msg[startIndex]
  return self

## ************************************************
##  FileACK : InformationObject
## ***********************************************

proc FileACK_encode*(self: FileACK; frame: Frame;
                    parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof mod 256)))
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof div 256)))
  Frame_setNextByte(frame, self.nameOfSection)
  Frame_setNextByte(frame, self.afq)
  return true

var FileACKVFT*: sInformationObjectVFT = [cast[EncodeFunction](FileACK_encode),
                                      cast[DestroyFunction](FileACK_destroy)]

proc FileACK_initialize*(self: FileACK) =
  self.virtualFunctionTable = addr((FileACKVFT))
  self.`type` = F_AF_NA_1

proc FileACK_create*(self: FileACK; ioa: cint; nof: uint16_t; nos: uint8_t; afq: uint8_t): FileACK =
  if self == nil:
    self = cast[FileACK](GLOBAL_MALLOC(sizeof(sFileACK)))
  if self != nil:
    FileACK_initialize(self)
    self.objectAddress = ioa
    self.nof = nof
    self.nameOfSection = nos
    self.afq = afq
  return self

proc FileACK_getNOF*(self: FileACK): uint16_t =
  return self.nof

proc FileACK_getNameOfSection*(self: FileACK): uint8_t =
  return self.nameOfSection

proc FileACK_getAFQ*(self: FileACK): uint8_t =
  return self.afq

proc FileACK_destroy*(self: FileACK) =
  GLOBAL_FREEMEM(self)

proc FileACK_getFromBuffer*(self: FileACK; parameters: CS101_AppLayerParameters;
                           msg: ptr uint8_t; msgSize: cint; startIndex: cint): FileACK =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 4:
    return nil
  if self == nil:
    self = cast[FileACK](GLOBAL_MALLOC(sizeof(sFileACK)))
  if self != nil:
    FileACK_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.nof = msg[inc(startIndex)]
    inc(self.nof, (msg[inc(startIndex)] * 0x00000000))
    self.nameOfSection = msg[inc(startIndex)]
    self.afq = msg[startIndex]
  return self

## ************************************************
##  FileSegment : InformationObject
## ***********************************************

proc FileSegment_encode*(self: FileSegment; frame: Frame;
                        parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  if self.los > FileSegment_GetMaxDataSize(parameters):
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof mod 256)))
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof div 256)))
  Frame_setNextByte(frame, self.nameOfSection)
  Frame_setNextByte(frame, self.los)
  Frame_appendBytes(frame, self.data, self.los)
  return true

var FileSegmentVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](FileSegment_encode),
    cast[DestroyFunction](FileSegment_destroy)]

proc FileSegment_initialize*(self: FileSegment) =
  self.virtualFunctionTable = addr((FileSegmentVFT))
  self.`type` = F_SG_NA_1

proc FileSegment_create*(self: FileSegment; ioa: cint; nof: uint16_t; nos: uint8_t;
                        data: ptr uint8_t; los: uint8_t): FileSegment =
  if self == nil:
    self = cast[FileSegment](GLOBAL_MALLOC(sizeof(sFileSegment)))
  if self != nil:
    FileSegment_initialize(self)
    self.objectAddress = ioa
    self.nof = nof
    self.nameOfSection = nos
    self.data = data
    self.los = los
  return self

proc FileSegment_getNOF*(self: FileSegment): uint16_t =
  return self.nof

proc FileSegment_getNameOfSection*(self: FileSegment): uint8_t =
  return self.nameOfSection

proc FileSegment_getLengthOfSegment*(self: FileSegment): uint8_t =
  return self.los

proc FileSegment_getSegmentData*(self: FileSegment): ptr uint8_t =
  return self.data

proc FileSegment_GetMaxDataSize*(parameters: CS101_AppLayerParameters): cint =
  var maxSize: cint = parameters.maxSizeOfASDU - parameters.sizeOfTypeId -
      parameters.sizeOfVSQ - parameters.sizeOfCA - parameters.sizeOfCOT
  return maxSize

proc FileSegment_destroy*(self: FileSegment) =
  GLOBAL_FREEMEM(self)

proc FileSegment_getFromBuffer*(self: FileSegment;
                               parameters: CS101_AppLayerParameters;
                               msg: ptr uint8_t; msgSize: cint; startIndex: cint): FileSegment =
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 4:
    return nil
  var los: uint8_t = msg[startIndex + 3 + parameters.sizeOfIOA]
  if (msgSize - startIndex) < (parameters.sizeOfIOA) + 4 + los:
    return nil
  if self == nil:
    self = cast[FileSegment](GLOBAL_MALLOC(sizeof(sFileSegment)))
  if self != nil:
    FileSegment_initialize(self)
    InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                    msg, startIndex)
    inc(startIndex, parameters.sizeOfIOA)
    ##  skip IOA
    self.nof = msg[inc(startIndex)]
    inc(self.nof, (msg[inc(startIndex)] * 0x00000000))
    self.nameOfSection = msg[inc(startIndex)]
    self.los = msg[inc(startIndex)]
    self.data = msg + startIndex
  return self

## ************************************************
##  FileDirectory: InformationObject
## ***********************************************

proc FileDirectory_encode*(self: FileDirectory; frame: Frame;
                          parameters: CS101_AppLayerParameters; isSequence: bool): bool =
  var size: cint = if isSequence: 13 else: (parameters.sizeOfIOA + 13)
  if Frame_getSpaceLeft(frame) < size:
    return false
  InformationObject_encodeBase(cast[InformationObject](self), frame, parameters,
                               isSequence)
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof mod 256)))
  Frame_setNextByte(frame, (uint8_t)(cast[cint](self.nof div 256)))
  Frame_setNextByte(frame, (uint8_t)(self.lengthOfFile mod 0x00000000))
  Frame_setNextByte(frame, (uint8_t)((self.lengthOfFile div 0x00000000) mod
      0x00000000))
  Frame_setNextByte(frame, (uint8_t)((self.lengthOfFile div 0x00000000) mod
      0x00000000))
  Frame_setNextByte(frame, self.sof)
  Frame_appendBytes(frame, self.creationTime.encodedValue, 7)
  return true

var FileDirectoryVFT*: sInformationObjectVFT = [
    cast[EncodeFunction](FileDirectory_encode),
    cast[DestroyFunction](FileDirectory_destroy)]

proc FileDirectory_initialize*(self: FileDirectory) =
  self.virtualFunctionTable = addr((FileDirectoryVFT))
  self.`type` = F_DR_TA_1

proc FileDirectory_create*(self: FileDirectory; ioa: cint; nof: uint16_t;
                          lengthOfFile: cint; sof: uint8_t; creationTime: CP56Time2a): FileDirectory =
  if self == nil:
    self = cast[FileDirectory](GLOBAL_MALLOC(sizeof(sFileDirectory)))
  if self != nil:
    FileDirectory_initialize(self)
    self.objectAddress = ioa
    self.nof = nof
    self.sof = sof
    self.creationTime = creationTime[]
  return self

proc FileDirectory_getNOF*(self: FileDirectory): uint16_t =
  return self.nof

proc FileDirectory_getSOF*(self: FileDirectory): uint8_t =
  return self.sof

proc FileDirectory_getSTATUS*(self: FileDirectory): cint =
  return (int)(self.sof and CS101_SOF_STATUS)

proc FileDirectory_getLFD*(self: FileDirectory): bool =
  return (self.sof and CS101_SOF_LFD) == CS101_SOF_LFD

proc FileDirectory_getFOR*(self: FileDirectory): bool =
  return (self.sof and CS101_SOF_FOR) == CS101_SOF_FOR

proc FileDirectory_getFA*(self: FileDirectory): bool =
  return (self.sof and CS101_SOF_FA) == CS101_SOF_FA

proc FileDirectory_getLengthOfFile*(self: FileDirectory): uint8_t =
  return self.lengthOfFile

proc FileDirectory_getCreationTime*(self: FileDirectory): CP56Time2a =
  return addr((self.creationTime))

proc FileDirectory_destroy*(self: FileDirectory) =
  GLOBAL_FREEMEM(self)

proc FileDirectory_getFromBuffer*(self: FileDirectory;
                                 parameters: CS101_AppLayerParameters;
                                 msg: ptr uint8_t; msgSize: cint; startIndex: cint;
                                 isSequence: bool): FileDirectory =
  if self == nil:
    self = cast[FileDirectory](GLOBAL_MALLOC(sizeof(sFileDirectory)))
  if self != nil:
    FileDirectory_initialize(self)
    if not isSequence:
      InformationObject_getFromBuffer(cast[InformationObject](self), parameters,
                                      msg, startIndex)
      inc(startIndex, parameters.sizeOfIOA)
      ##  skip IOA
    self.nof = msg[inc(startIndex)]
    inc(self.nof, (msg[inc(startIndex)] * 0x00000000))
    self.lengthOfFile = msg[inc(startIndex)]
    inc(self.lengthOfFile, (msg[inc(startIndex)] * 0x00000000))
    inc(self.lengthOfFile, (msg[inc(startIndex)] * 0x00000000))
    self.sof = msg[inc(startIndex)]
    CP56Time2a_getFromBuffer(addr((self.creationTime)), msg, msgSize, startIndex)
  return self
